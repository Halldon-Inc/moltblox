'use client';

import React, { useRef, useEffect, useCallback, useState } from 'react';

// ==========================================================================
// FPSRenderer: DOOM-style first-person raycaster
// Fully self-contained: maps, weapons, enemies, pickups, all game logic.
// Supports single-player AND multiplayer deathmatch via WebSocket.
// ==========================================================================

interface FPSRendererProps {
  gameName?: string;
  gameConfig?: Record<string, unknown>;
}

// --------------------------------------------------------------------------
// Particle system types
// --------------------------------------------------------------------------

interface Particle {
  x: number;
  y: number;
  vx: number;
  vy: number;
  life: number;
  maxLife: number;
  color: string;
  size: number;
}

// --------------------------------------------------------------------------
// Kill feed types
// --------------------------------------------------------------------------

interface KillFeedEntry {
  text: string;
  time: number;
  color: string;
}

// --------------------------------------------------------------------------
// Consumable types
// --------------------------------------------------------------------------

interface ConsumableState {
  type: string;
  count: number;
}

// --------------------------------------------------------------------------
// Multiplayer types
// --------------------------------------------------------------------------

interface RemotePlayer {
  id: string;
  name: string;
  x: number;
  y: number;
  angle: number;
  health: number;
  weaponIndex: number;
  alive: boolean;
  prevX: number;
  prevY: number;
  prevAngle: number;
  lastUpdate: number;
}

// Player colors for multiplayer (assigned by join order)
const MP_PLAYER_COLORS = ['#22cc22', '#4488ff', '#aa44ff', '#ff8800'];

// --------------------------------------------------------------------------
// Constants
// --------------------------------------------------------------------------

const SCREEN_W = 960;
const SCREEN_H = 540;
const FOV = (Math.PI * 66) / 180;
const HALF_FOV = FOV / 2;
const MOVE_SPEED = 3.0;
const RUN_MULTIPLIER = 1.5;
const TURN_SPEED = 2.0;
const MOUSE_SENSITIVITY = 0.003;
const PLAYER_RADIUS = 0.2;
const PICKUP_RADIUS = 0.5;
const EXIT_RADIUS = 0.5;
const ENEMY_SIGHT_RANGE = 12;
const ENEMY_AI_INTERVAL = 100; // ms between AI updates
const KILL_FEED_DURATION = 4000; // ms
const KILL_FEED_MAX = 4;

// --------------------------------------------------------------------------
// Glove cosmetic colors
// --------------------------------------------------------------------------

const GLOVE_COLORS: Record<string, string> = {
  default: '#DEB887',
  tactical: '#2D2D2D',
  leather: '#8B4513',
  cyber: '#00FFFF',
  gold: '#FFD700',
  flame: '#FF4500',
  skeleton: '#FFFFFF',
};

// --------------------------------------------------------------------------
// Wall colors by map tile value
// --------------------------------------------------------------------------

const WALL_COLORS: Record<number, [number, number, number]> = {
  1: [100, 95, 90], // stone gray (cooler)
  2: [150, 55, 40], // dark red brick
  3: [50, 65, 140], // deep blue tech
  4: [45, 110, 50], // dark green
  5: [170, 150, 50], // gold door
};

// --------------------------------------------------------------------------
// Procedural wall textures (64x64, generated once)
// Each texture is a flat Uint8Array of length 64*64*3 (RGB)
// --------------------------------------------------------------------------

const TEX_SIZE = 64;

function generateWallTextures(): Uint8Array[] {
  const textures: Uint8Array[] = [];

  // Helper: set pixel in texture buffer
  const setPixel = (buf: Uint8Array, x: number, y: number, r: number, g: number, b: number) => {
    if (x < 0 || x >= TEX_SIZE || y < 0 || y >= TEX_SIZE) return;
    const idx = (y * TEX_SIZE + x) * 3;
    buf[idx] = r;
    buf[idx + 1] = g;
    buf[idx + 2] = b;
  };

  // Simple seeded pseudo-random for deterministic textures
  const seedRng = (seed: number) => {
    let s = seed;
    return () => {
      s = (s * 1103515245 + 12345) & 0x7fffffff;
      return (s >>> 16) / 32768;
    };
  };

  // Texture 0: Stone/concrete (wall type 1)
  {
    const buf = new Uint8Array(TEX_SIZE * TEX_SIZE * 3);
    const rng = seedRng(42);
    for (let y = 0; y < TEX_SIZE; y++) {
      for (let x = 0; x < TEX_SIZE; x++) {
        const noise = (rng() - 0.5) * 30;
        let r = 95 + noise;
        let g = 90 + noise;
        let b = 85 + noise;
        // Grout lines (every 16 pixels, offset alternate rows)
        const brickH = 8;
        const brickW = 16;
        const rowOffset = (Math.floor(y / brickH) % 2) * (brickW / 2);
        const localX = (x + rowOffset) % brickW;
        const localY = y % brickH;
        if (localY === 0 || localX === 0) {
          r = 60 + (rng() - 0.5) * 10;
          g = 58 + (rng() - 0.5) * 10;
          b = 55 + (rng() - 0.5) * 10;
        }
        // Occasional darker spots
        if (rng() < 0.03) {
          r *= 0.7;
          g *= 0.7;
          b *= 0.7;
        }
        setPixel(
          buf,
          x,
          y,
          clamp(Math.floor(r), 0, 255),
          clamp(Math.floor(g), 0, 255),
          clamp(Math.floor(b), 0, 255),
        );
      }
    }
    textures.push(buf);
  }

  // Texture 1: Red brick (wall type 2)
  {
    const buf = new Uint8Array(TEX_SIZE * TEX_SIZE * 3);
    const rng = seedRng(137);
    for (let y = 0; y < TEX_SIZE; y++) {
      for (let x = 0; x < TEX_SIZE; x++) {
        const brickH = 8;
        const brickW = 16;
        const rowOffset = (Math.floor(y / brickH) % 2) * (brickW / 2);
        const localX = (x + rowOffset) % brickW;
        const localY = y % brickH;
        const noise = (rng() - 0.5) * 20;
        if (localY === 0 || localY === 1 || localX === 0) {
          // Mortar
          const mr = 80 + (rng() - 0.5) * 15;
          const mg = 75 + (rng() - 0.5) * 15;
          const mb = 70 + (rng() - 0.5) * 15;
          setPixel(
            buf,
            x,
            y,
            clamp(Math.floor(mr), 0, 255),
            clamp(Math.floor(mg), 0, 255),
            clamp(Math.floor(mb), 0, 255),
          );
        } else {
          // Brick face
          let r = 145 + noise;
          let g = 50 + noise * 0.4;
          const b = 35 + noise * 0.3;
          // Slight color variation per brick
          const brickId = Math.floor(y / brickH) * 4 + Math.floor((x + rowOffset) / brickW);
          const brickShift = ((brickId * 7 + 3) % 20) - 10;
          r += brickShift;
          g += brickShift * 0.3;
          setPixel(
            buf,
            x,
            y,
            clamp(Math.floor(r), 0, 255),
            clamp(Math.floor(g), 0, 255),
            clamp(Math.floor(b), 0, 255),
          );
        }
      }
    }
    textures.push(buf);
  }

  // Texture 2: Tech panel (wall type 3)
  {
    const buf = new Uint8Array(TEX_SIZE * TEX_SIZE * 3);
    const rng = seedRng(256);
    for (let y = 0; y < TEX_SIZE; y++) {
      for (let x = 0; x < TEX_SIZE; x++) {
        const noise = (rng() - 0.5) * 12;
        let r = 40 + noise;
        let g = 50 + noise;
        let b = 120 + noise;
        // Grid lines every 16 pixels
        if (x % 16 === 0 || y % 16 === 0) {
          r = 70 + noise;
          g = 85 + noise;
          b = 170 + noise;
        }
        // Panel borders (thicker lines every 32 pixels)
        if (x % 32 < 2 || y % 32 < 2) {
          r = 30;
          g = 40;
          b = 80;
        }
        // Occasional lit panels (small bright squares)
        const panelX = Math.floor(x / 16);
        const panelY = Math.floor(y / 16);
        const panelId = panelX * 5 + panelY * 3;
        if (panelId % 7 === 0) {
          const localPX = x % 16;
          const localPY = y % 16;
          if (localPX > 3 && localPX < 13 && localPY > 3 && localPY < 13) {
            r = 80 + noise;
            g = 140 + noise;
            b = 220;
          }
        }
        setPixel(
          buf,
          x,
          y,
          clamp(Math.floor(r), 0, 255),
          clamp(Math.floor(g), 0, 255),
          clamp(Math.floor(b), 0, 255),
        );
      }
    }
    textures.push(buf);
  }

  // Texture 3: Green moss / organic (wall type 4)
  {
    const buf = new Uint8Array(TEX_SIZE * TEX_SIZE * 3);
    const rng = seedRng(389);
    for (let y = 0; y < TEX_SIZE; y++) {
      for (let x = 0; x < TEX_SIZE; x++) {
        const noise1 = (rng() - 0.5) * 35;
        const noise2 = (rng() - 0.5) * 20;
        // Base organic green with color variation
        let r = 35 + noise2;
        let g = 95 + noise1;
        let b = 40 + noise2;
        // Vein-like darker lines
        const veinX = Math.sin(y * 0.3 + x * 0.1) * 8;
        if (Math.abs(((x + veinX) % 12) - 6) < 1.5) {
          r *= 0.6;
          g *= 0.7;
          b *= 0.5;
        }
        // Occasional lighter moss patches
        if (rng() < 0.05) {
          r += 20;
          g += 30;
          b += 10;
        }
        setPixel(
          buf,
          x,
          y,
          clamp(Math.floor(r), 0, 255),
          clamp(Math.floor(g), 0, 255),
          clamp(Math.floor(b), 0, 255),
        );
      }
    }
    textures.push(buf);
  }

  // Texture 4: Gold door / metallic (wall type 5)
  {
    const buf = new Uint8Array(TEX_SIZE * TEX_SIZE * 3);
    const rng = seedRng(512);
    for (let y = 0; y < TEX_SIZE; y++) {
      for (let x = 0; x < TEX_SIZE; x++) {
        const noise = (rng() - 0.5) * 15;
        let r = 160 + noise;
        let g = 140 + noise;
        let b = 45 + noise * 0.5;
        // Vertical panel lines
        if (x % 32 < 2 || x % 32 > 29) {
          r = 100;
          g = 85;
          b = 30;
        }
        // Horizontal panel lines
        if (y % 32 < 2 || y % 32 > 29) {
          r = 100;
          g = 85;
          b = 30;
        }
        // Rivet details (small circles at panel corners)
        const cornerX = x % 32;
        const cornerY = y % 32;
        if (
          (cornerX < 5 && cornerY < 5) ||
          (cornerX > 27 && cornerY < 5) ||
          (cornerX < 5 && cornerY > 27) ||
          (cornerX > 27 && cornerY > 27)
        ) {
          const cx = cornerX < 16 ? 3 : 29;
          const cy = cornerY < 16 ? 3 : 29;
          const dist = Math.sqrt((cornerX - cx) * (cornerX - cx) + (cornerY - cy) * (cornerY - cy));
          if (dist < 2.5) {
            r = 130 + (2.5 - dist) * 20;
            g = 110 + (2.5 - dist) * 15;
            b = 35;
          }
        }
        // Central metallic sheen (lighter in middle of panel)
        const midX = Math.abs((x % 32) - 16) / 16;
        const midY = Math.abs((y % 32) - 16) / 16;
        const sheen = 1 - (midX * 0.3 + midY * 0.3);
        r *= sheen;
        g *= sheen;
        b *= sheen;
        setPixel(
          buf,
          x,
          y,
          clamp(Math.floor(r), 0, 255),
          clamp(Math.floor(g), 0, 255),
          clamp(Math.floor(b), 0, 255),
        );
      }
    }
    textures.push(buf);
  }

  return textures;
}

// Pre-generated textures (created once at module load)
const WALL_TEXTURES = generateWallTextures();

// --------------------------------------------------------------------------
// Weapon pixel art sprites and palettes
// --------------------------------------------------------------------------

// Shared weapon palette: indices map to [R, G, B]
// 0 = transparent, 1-6 = metal dark to light, 7-10 = skin tones,
// 11-13 = wood, 14-16 = accent colors, 17 = black outline
const WEAPON_PALETTE: [number, number, number][] = [
  [0, 0, 0], // 0: transparent
  [30, 30, 35], // 1: metal darkest
  [50, 50, 55], // 2: metal dark
  [75, 75, 80], // 3: metal mid
  [100, 100, 108], // 4: metal light
  [130, 130, 140], // 5: metal highlight
  [160, 160, 175], // 6: metal brightest
  [180, 130, 90], // 7: skin dark
  [210, 160, 120], // 8: skin mid
  [230, 185, 145], // 9: skin light
  [240, 200, 165], // 10: skin highlight
  [80, 50, 25], // 11: wood dark
  [110, 70, 35], // 12: wood mid
  [140, 95, 50], // 13: wood light
  [180, 40, 30], // 14: red accent
  [50, 80, 40], // 15: olive drab
  [40, 160, 40], // 16: green glow
  [15, 15, 18], // 17: black outline
  [255, 255, 200], // 18: muzzle flash
  [60, 60, 65], // 19: dark gray detail
  [200, 180, 60], // 20: gold/brass
  [120, 100, 40], // 21: dark gold
];

// Fist sprite: 20 wide x 22 tall
// Shows a closed fist from behind with 4 fingers curled, knuckles, thumb
const FIST_SPRITE: number[][] = [
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 17, 17, 17, 0, 17, 17, 17, 0, 17, 17, 17, 0, 0, 0, 0],
  [0, 0, 0, 0, 17, 9, 9, 9, 17, 9, 9, 9, 17, 9, 9, 9, 17, 0, 0, 0],
  [0, 0, 0, 0, 17, 9, 10, 9, 17, 9, 10, 9, 17, 9, 10, 9, 17, 0, 0, 0],
  [0, 0, 0, 0, 17, 9, 9, 9, 17, 9, 9, 9, 17, 9, 9, 9, 17, 0, 0, 0],
  [0, 0, 0, 17, 17, 8, 8, 8, 17, 8, 8, 8, 17, 8, 8, 8, 17, 17, 0, 0],
  [0, 0, 17, 9, 17, 8, 7, 8, 17, 8, 7, 8, 17, 8, 7, 8, 17, 9, 17, 0],
  [0, 0, 17, 9, 17, 8, 8, 8, 17, 8, 8, 8, 17, 8, 8, 8, 17, 9, 17, 0],
  [0, 0, 17, 10, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 10, 17, 0],
  [0, 17, 9, 10, 9, 9, 9, 9, 8, 8, 8, 8, 9, 9, 9, 9, 9, 10, 9, 17],
  [0, 17, 9, 9, 9, 9, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 17],
  [0, 17, 8, 8, 9, 9, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 8, 8, 8, 17],
  [0, 17, 8, 8, 8, 8, 8, 7, 7, 8, 8, 7, 7, 8, 8, 8, 8, 8, 8, 17],
  [0, 0, 17, 8, 8, 8, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 17, 0],
  [0, 0, 17, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 17, 0],
  [0, 0, 17, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 17, 0],
  [0, 0, 0, 17, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 17, 0, 0],
  [0, 0, 0, 17, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 17, 0, 0],
  [0, 0, 0, 0, 17, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 17, 0, 0, 0],
  [0, 0, 0, 0, 0, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
];

// Pistol sprite: 24 wide x 32 tall
const PISTOL_SPRITE: number[][] = [
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 17, 17, 17, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 17, 2, 2, 2, 2, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 17, 2, 3, 3, 2, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 17, 2, 3, 3, 2, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 17, 1, 1, 2, 2, 1, 1, 17, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 17, 2, 3, 4, 4, 3, 2, 17, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 17, 2, 3, 5, 5, 3, 2, 17, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 17, 2, 3, 4, 4, 3, 2, 17, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 17, 2, 3, 3, 3, 3, 2, 17, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 17, 2, 2, 3, 3, 2, 2, 17, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 17, 1, 2, 2, 2, 2, 1, 17, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 17, 2, 3, 3, 3, 3, 2, 17, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 17, 19, 19, 3, 3, 19, 19, 17, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 17, 0, 2, 2, 0, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 17, 0, 2, 2, 0, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 17, 2, 17, 2, 2, 17, 2, 17, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 17, 2, 2, 2, 2, 2, 2, 17, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 17, 1, 1, 2, 2, 1, 1, 17, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 17, 9, 9, 9, 8, 8, 8, 8, 8, 8, 9, 9, 17, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 17, 9, 9, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 17, 0, 0, 0, 0, 0],
  [0, 0, 0, 17, 10, 9, 17, 8, 17, 8, 17, 8, 17, 8, 17, 8, 9, 10, 17, 0, 0, 0, 0, 0],
  [0, 0, 0, 17, 9, 9, 17, 8, 17, 8, 17, 8, 17, 8, 17, 8, 9, 9, 17, 0, 0, 0, 0, 0],
  [0, 0, 17, 9, 8, 8, 17, 7, 17, 7, 17, 7, 17, 7, 17, 7, 8, 8, 9, 17, 0, 0, 0, 0],
  [0, 0, 17, 8, 8, 7, 17, 7, 17, 7, 17, 7, 17, 7, 17, 7, 7, 8, 8, 17, 0, 0, 0, 0],
  [0, 0, 0, 17, 8, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 17, 0, 0, 0, 0, 0],
  [0, 0, 0, 17, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 17, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 17, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 17, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
];

// Shotgun sprite: 32 wide x 36 tall
const SHOTGUN_SPRITE: number[][] = [
  [
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 17, 17, 17, 17, 17, 17, 17, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0,
  ],
  [
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 17, 2, 2, 3, 3, 3, 3, 2, 2, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0,
  ],
  [
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 17, 1, 17, 2, 3, 3, 2, 17, 1, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0,
  ],
  [
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 17, 2, 2, 3, 3, 3, 3, 2, 2, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0,
  ],
  [
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 17, 2, 2, 3, 4, 4, 3, 2, 2, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0,
  ],
  [
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 17, 2, 3, 4, 5, 5, 4, 3, 2, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0,
  ],
  [
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 17, 2, 3, 3, 4, 4, 3, 3, 2, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0,
  ],
  [
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 17, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0,
  ],
  [
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 17, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0,
  ],
  [
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 17, 2, 3, 3, 3, 3, 3, 3, 2, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0,
  ],
  [
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 17, 2, 2, 3, 3, 3, 3, 2, 2, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0,
  ],
  [
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 17, 2, 2, 2, 3, 3, 2, 2, 2, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0,
  ],
  [
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 17, 11, 12, 12, 12, 12, 12, 12, 11, 17, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0,
  ],
  [
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 17, 12, 13, 11, 13, 13, 11, 13, 12, 17, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0,
  ],
  [
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 17, 11, 12, 13, 12, 12, 13, 12, 11, 17, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0,
  ],
  [
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 17, 12, 13, 11, 13, 13, 11, 13, 12, 17, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0,
  ],
  [
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 17, 11, 12, 12, 12, 12, 12, 12, 11, 17, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0,
  ],
  [
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 17, 12, 11, 12, 11, 11, 12, 11, 12, 17, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0,
  ],
  [
    0, 0, 0, 0, 0, 0, 0, 0, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 0, 0, 0, 0,
    0, 0, 0, 0, 0,
  ],
  [
    0, 0, 0, 0, 0, 0, 17, 9, 9, 9, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 17, 0, 0, 0, 0, 0, 0, 0,
    0,
  ],
  [
    0, 0, 0, 0, 0, 17, 9, 9, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 17, 0, 0, 0, 0, 0, 0,
    0,
  ],
  [
    0, 0, 0, 0, 17, 10, 9, 17, 8, 17, 8, 17, 8, 17, 8, 17, 8, 17, 8, 17, 8, 9, 10, 17, 0, 0, 0, 0,
    0, 0, 0, 0,
  ],
  [
    0, 0, 0, 0, 17, 9, 9, 17, 8, 17, 8, 17, 8, 17, 8, 17, 8, 17, 8, 17, 8, 9, 9, 17, 0, 0, 0, 0, 0,
    0, 0, 0,
  ],
  [
    0, 0, 0, 17, 9, 8, 8, 17, 7, 17, 7, 17, 7, 17, 7, 17, 7, 17, 7, 17, 7, 8, 8, 9, 17, 0, 0, 0, 0,
    0, 0, 0,
  ],
  [
    0, 0, 0, 17, 8, 8, 7, 17, 7, 17, 7, 17, 7, 17, 7, 17, 7, 17, 7, 17, 7, 7, 8, 8, 17, 0, 0, 0, 0,
    0, 0, 0,
  ],
  [
    0, 0, 0, 0, 17, 8, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 17, 0, 0, 0, 0, 0, 0, 0,
    0,
  ],
  [
    0, 0, 0, 0, 17, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 17, 0, 0, 0, 0, 0, 0, 0,
    0,
  ],
  [
    0, 0, 0, 0, 0, 17, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 17, 0, 0, 0, 0, 0, 0, 0, 0,
    0,
  ],
  [
    0, 0, 0, 0, 0, 0, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0,
  ],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
];

// Chaingun sprite: 28 wide x 36 tall
const CHAINGUN_SPRITE: number[][] = [
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 17, 17, 0, 0, 0, 0, 17, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 17, 2, 2, 17, 0, 0, 17, 2, 2, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 17, 1, 2, 17, 0, 0, 17, 2, 1, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 17, 2, 2, 3, 17, 0, 0, 17, 3, 2, 2, 17, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 17, 2, 2, 3, 17, 17, 17, 17, 3, 2, 2, 17, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 17, 3, 3, 4, 3, 3, 3, 3, 4, 3, 3, 17, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 17, 2, 3, 4, 4, 4, 4, 4, 4, 3, 2, 17, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 17, 2, 3, 3, 4, 5, 5, 4, 3, 3, 2, 17, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 17, 19, 2, 2, 3, 3, 4, 4, 3, 3, 2, 2, 19, 17, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 17, 19, 2, 2, 3, 3, 3, 3, 3, 3, 2, 2, 19, 17, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 17, 2, 2, 2, 2, 3, 3, 3, 3, 2, 2, 2, 2, 17, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 17, 2, 2, 2, 2, 2, 3, 3, 2, 2, 2, 2, 2, 17, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 17, 20, 20, 2, 2, 2, 2, 2, 2, 2, 2, 20, 20, 17, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 17, 21, 20, 2, 2, 2, 2, 2, 2, 2, 2, 20, 21, 17, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 17, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 17, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 17, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 17, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 17, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 17, 0, 0, 0, 0, 0, 0, 0],
  [
    0, 0, 0, 0, 0, 0, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 0, 0, 0, 0, 0,
    0,
  ],
  [0, 0, 0, 0, 0, 17, 9, 9, 9, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 17, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 17, 9, 9, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 17, 0, 0, 0, 0],
  [0, 0, 0, 17, 10, 9, 17, 8, 17, 8, 17, 8, 17, 8, 17, 8, 17, 8, 17, 8, 9, 10, 17, 0, 0, 0, 0, 0],
  [0, 0, 0, 17, 9, 9, 17, 8, 17, 8, 17, 8, 17, 8, 17, 8, 17, 8, 17, 8, 9, 9, 17, 0, 0, 0, 0, 0],
  [0, 0, 17, 9, 8, 8, 17, 7, 17, 7, 17, 7, 17, 7, 17, 7, 17, 7, 17, 7, 8, 8, 9, 17, 0, 0, 0, 0],
  [0, 0, 17, 8, 8, 7, 17, 7, 17, 7, 17, 7, 17, 7, 17, 7, 17, 7, 17, 7, 7, 8, 8, 17, 0, 0, 0, 0],
  [0, 0, 0, 17, 8, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 17, 0, 0, 0, 0, 0],
  [0, 0, 0, 17, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 17, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 17, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 17, 0, 0, 0, 0, 0, 0],
  [
    0, 0, 0, 0, 0, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 0, 0, 0, 0, 0, 0,
    0,
  ],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
];

// Rocket Launcher sprite: 30 wide x 36 tall
const ROCKET_SPRITE: number[][] = [
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 17, 17, 17, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 17, 3, 4, 4, 3, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  [
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 17, 15, 15, 15, 15, 15, 15, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0,
  ],
  [
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 17, 15, 15, 15, 15, 15, 15, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0,
  ],
  [
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 17, 17, 15, 15, 15, 15, 15, 15, 17, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0,
  ],
  [
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 17, 2, 15, 15, 15, 15, 15, 15, 2, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0,
  ],
  [
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 17, 2, 15, 15, 15, 15, 15, 15, 2, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0,
  ],
  [
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 17, 2, 15, 15, 15, 15, 15, 15, 2, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0,
  ],
  [
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 17, 19, 15, 15, 15, 15, 15, 15, 19, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0,
  ],
  [
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 17, 2, 15, 15, 15, 15, 15, 15, 2, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0,
  ],
  [
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 17, 2, 15, 15, 15, 15, 15, 15, 2, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0,
  ],
  [
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 17, 19, 15, 15, 15, 15, 15, 15, 19, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0,
  ],
  [
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 17, 2, 15, 15, 15, 15, 15, 15, 2, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0,
  ],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 17, 2, 2, 15, 15, 15, 15, 2, 2, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 17, 2, 2, 2, 2, 2, 2, 2, 2, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 17, 1, 2, 2, 2, 2, 2, 2, 1, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 17, 1, 1, 2, 2, 2, 2, 1, 1, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  [
    0, 0, 0, 0, 0, 0, 0, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 0, 0, 0, 0,
    0, 0, 0,
  ],
  [0, 0, 0, 0, 0, 0, 17, 9, 9, 9, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 17, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 17, 9, 9, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 17, 0, 0, 0, 0, 0],
  [
    0, 0, 0, 0, 17, 10, 9, 17, 8, 17, 8, 17, 8, 17, 8, 17, 8, 17, 8, 17, 8, 9, 10, 17, 0, 0, 0, 0,
    0, 0,
  ],
  [
    0, 0, 0, 0, 17, 9, 9, 17, 8, 17, 8, 17, 8, 17, 8, 17, 8, 17, 8, 17, 8, 9, 9, 17, 0, 0, 0, 0, 0,
    0,
  ],
  [
    0, 0, 0, 17, 9, 8, 8, 17, 7, 17, 7, 17, 7, 17, 7, 17, 7, 17, 7, 17, 7, 8, 8, 9, 17, 0, 0, 0, 0,
    0,
  ],
  [
    0, 0, 0, 17, 8, 8, 7, 17, 7, 17, 7, 17, 7, 17, 7, 17, 7, 17, 7, 17, 7, 7, 8, 8, 17, 0, 0, 0, 0,
    0,
  ],
  [0, 0, 0, 0, 17, 8, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 17, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 17, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 17, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 17, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 17, 0, 0, 0, 0, 0, 0, 0],
  [
    0, 0, 0, 0, 0, 0, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 0, 0, 0, 0, 0,
    0, 0, 0,
  ],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
];

// BFG sprite: 32 wide x 36 tall
const BFG_SPRITE: number[][] = [
  [
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16, 16, 16, 16, 16, 16, 16, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0,
  ],
  [
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0,
  ],
  [
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16, 16, 16, 18, 18, 18, 18, 18, 16, 16, 16, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0,
  ],
  [
    0, 0, 0, 0, 0, 0, 0, 0, 0, 16, 16, 16, 18, 18, 18, 18, 18, 18, 18, 16, 16, 16, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0,
  ],
  [
    0, 0, 0, 0, 0, 0, 0, 0, 0, 16, 16, 18, 18, 16, 16, 16, 16, 16, 18, 18, 16, 16, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0,
  ],
  [
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0,
  ],
  [
    0, 0, 0, 0, 0, 0, 0, 0, 0, 17, 17, 2, 2, 2, 2, 2, 2, 2, 2, 2, 17, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0,
  ],
  [
    0, 0, 0, 0, 0, 0, 0, 0, 17, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0,
  ],
  [
    0, 0, 0, 0, 0, 0, 0, 17, 2, 2, 3, 3, 3, 4, 4, 4, 4, 3, 3, 3, 2, 2, 17, 0, 0, 0, 0, 0, 0, 0, 0,
    0,
  ],
  [
    0, 0, 0, 0, 0, 0, 0, 17, 2, 3, 3, 16, 16, 16, 16, 16, 16, 16, 3, 3, 2, 17, 0, 0, 0, 0, 0, 0, 0,
    0,
  ],
  [
    0, 0, 0, 0, 0, 0, 0, 17, 2, 3, 16, 16, 16, 16, 16, 16, 16, 16, 16, 3, 2, 17, 0, 0, 0, 0, 0, 0,
    0, 0,
  ],
  [
    0, 0, 0, 0, 0, 0, 0, 17, 2, 3, 3, 16, 16, 16, 16, 16, 16, 16, 3, 3, 2, 17, 0, 0, 0, 0, 0, 0, 0,
    0,
  ],
  [
    0, 0, 0, 0, 0, 0, 0, 17, 2, 2, 3, 3, 3, 4, 4, 4, 4, 3, 3, 3, 2, 2, 17, 0, 0, 0, 0, 0, 0, 0, 0,
    0,
  ],
  [
    0, 0, 0, 0, 0, 0, 0, 0, 17, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0,
  ],
  [
    0, 0, 0, 0, 0, 0, 0, 0, 0, 17, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0,
  ],
  [
    0, 0, 0, 0, 0, 0, 0, 0, 0, 17, 1, 1, 2, 2, 2, 2, 2, 2, 1, 1, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0,
  ],
  [
    0, 0, 0, 0, 0, 0, 0, 0, 0, 17, 1, 1, 1, 2, 2, 2, 2, 1, 1, 1, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0,
  ],
  [
    0, 0, 0, 0, 0, 0, 0, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 0, 0, 0, 0,
    0, 0, 0, 0, 0,
  ],
  [
    0, 0, 0, 0, 0, 0, 17, 9, 9, 9, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 17, 0, 0, 0, 0, 0, 0, 0,
    0,
  ],
  [
    0, 0, 0, 0, 0, 17, 9, 9, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 17, 0, 0, 0, 0, 0, 0,
    0,
  ],
  [
    0, 0, 0, 0, 17, 10, 9, 17, 8, 17, 8, 17, 8, 17, 8, 17, 8, 17, 8, 17, 8, 9, 10, 17, 0, 0, 0, 0,
    0, 0, 0, 0,
  ],
  [
    0, 0, 0, 0, 17, 9, 9, 17, 8, 17, 8, 17, 8, 17, 8, 17, 8, 17, 8, 17, 8, 9, 9, 17, 0, 0, 0, 0, 0,
    0, 0, 0,
  ],
  [
    0, 0, 0, 17, 9, 8, 8, 17, 7, 17, 7, 17, 7, 17, 7, 17, 7, 17, 7, 17, 7, 8, 8, 9, 17, 0, 0, 0, 0,
    0, 0, 0,
  ],
  [
    0, 0, 0, 17, 8, 8, 7, 17, 7, 17, 7, 17, 7, 17, 7, 17, 7, 17, 7, 17, 7, 7, 8, 8, 17, 0, 0, 0, 0,
    0, 0, 0,
  ],
  [
    0, 0, 0, 0, 17, 8, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 17, 0, 0, 0, 0, 0, 0, 0,
    0,
  ],
  [
    0, 0, 0, 0, 17, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 17, 0, 0, 0, 0, 0, 0, 0,
    0,
  ],
  [
    0, 0, 0, 0, 0, 17, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 17, 0, 0, 0, 0, 0, 0, 0, 0,
    0,
  ],
  [
    0, 0, 0, 0, 0, 0, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0,
  ],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
];

// All weapon sprites indexed by weapon slot
const WEAPON_SPRITES: number[][][] = [
  FIST_SPRITE,
  PISTOL_SPRITE,
  SHOTGUN_SPRITE,
  CHAINGUN_SPRITE,
  ROCKET_SPRITE,
  BFG_SPRITE,
];

// --------------------------------------------------------------------------
// Enemy pixel art sprites and palettes
// --------------------------------------------------------------------------

// Enemy palettes: each type has its own color ramp
// Index 0 = transparent, indices 1-8 from darkest to brightest, 9 = eye color
const ENEMY_PALETTES: Record<string, [number, number, number][]> = {
  grunt: [
    [0, 0, 0], // 0: transparent
    [30, 18, 8], // 1: darkest brown (outline)
    [65, 40, 20], // 2: dark brown
    [100, 65, 30], // 3: mid brown
    [130, 85, 42], // 4: brown
    [155, 105, 55], // 5: light brown
    [175, 130, 80], // 6: lightest brown
    [200, 155, 100], // 7: highlight
    [40, 15, 10], // 8: very dark (belt/detail)
    [220, 40, 40], // 9: red eyes
  ],
  soldier: [
    [0, 0, 0], // 0: transparent
    [20, 22, 30], // 1: darkest blue-gray (outline)
    [45, 50, 60], // 2: dark blue-gray
    [70, 78, 95], // 3: mid blue-gray
    [95, 105, 125], // 4: blue-gray
    [115, 125, 145], // 5: light blue-gray
    [140, 150, 170], // 6: lightest
    [170, 180, 200], // 7: highlight
    [30, 30, 35], // 8: very dark (belt/detail)
    [200, 200, 40], // 9: yellow visor
  ],
  heavy: [
    [0, 0, 0], // 0: transparent
    [40, 8, 8], // 1: darkest red (outline)
    [80, 18, 18], // 2: dark red
    [120, 30, 28], // 3: mid red
    [155, 40, 35], // 4: red
    [180, 55, 45], // 5: light red
    [200, 80, 65], // 6: lightest
    [220, 110, 90], // 7: highlight
    [25, 5, 5], // 8: very dark (horns)
    [255, 180, 40], // 9: orange eyes
  ],
  boss: [
    [0, 0, 0], // 0: transparent
    [50, 5, 5], // 1: darkest crimson (outline)
    [90, 12, 12], // 2: dark crimson
    [140, 20, 18], // 3: mid crimson
    [180, 28, 25], // 4: crimson
    [210, 40, 35], // 5: light crimson
    [230, 65, 55], // 6: lightest
    [245, 100, 85], // 7: highlight
    [20, 2, 2], // 8: very dark (crown/wings)
    [255, 20, 20], // 9: glowing red eyes
  ],
};

// Grunt sprite: 16 wide x 20 tall
const GRUNT_SPRITE: number[][] = [
  [0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 1, 4, 5, 5, 5, 5, 4, 1, 0, 0, 0, 0],
  [0, 0, 0, 0, 1, 5, 6, 6, 6, 6, 5, 1, 0, 0, 0, 0],
  [0, 0, 0, 0, 1, 5, 9, 5, 5, 9, 5, 1, 0, 0, 0, 0],
  [0, 0, 0, 0, 1, 4, 4, 5, 5, 4, 4, 1, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 1, 4, 3, 3, 4, 1, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0],
  [0, 0, 1, 1, 1, 1, 3, 4, 4, 3, 1, 1, 1, 1, 0, 0],
  [0, 1, 3, 3, 1, 3, 4, 5, 5, 4, 3, 1, 3, 3, 1, 0],
  [0, 1, 2, 3, 1, 4, 5, 5, 5, 5, 4, 1, 3, 2, 1, 0],
  [0, 1, 2, 3, 1, 4, 4, 5, 5, 4, 4, 1, 3, 2, 1, 0],
  [0, 0, 1, 1, 1, 3, 4, 4, 4, 4, 3, 1, 1, 1, 0, 0],
  [0, 0, 0, 0, 1, 8, 8, 3, 3, 8, 8, 1, 0, 0, 0, 0],
  [0, 0, 0, 0, 1, 3, 3, 4, 4, 3, 3, 1, 0, 0, 0, 0],
  [0, 0, 0, 0, 1, 3, 3, 3, 3, 3, 3, 1, 0, 0, 0, 0],
  [0, 0, 0, 0, 1, 2, 3, 3, 3, 3, 2, 1, 0, 0, 0, 0],
  [0, 0, 0, 0, 1, 2, 2, 3, 3, 2, 2, 1, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 1, 2, 3, 1, 1, 3, 2, 1, 0, 0, 0, 0],
  [0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0],
];

// Soldier sprite: 16 wide x 22 tall
const SOLDIER_SPRITE: number[][] = [
  [0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0],
  [0, 0, 0, 1, 2, 2, 3, 3, 3, 3, 2, 2, 1, 0, 0, 0],
  [0, 0, 0, 1, 3, 4, 4, 4, 4, 4, 4, 3, 1, 0, 0, 0],
  [0, 0, 0, 1, 3, 9, 3, 4, 4, 3, 9, 3, 1, 0, 0, 0],
  [0, 0, 0, 1, 3, 3, 4, 4, 4, 4, 3, 3, 1, 0, 0, 0],
  [0, 0, 0, 0, 1, 3, 3, 2, 2, 3, 3, 1, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0],
  [0, 1, 1, 1, 1, 3, 4, 5, 5, 4, 3, 1, 1, 1, 1, 0],
  [1, 3, 2, 1, 3, 4, 5, 5, 5, 5, 4, 3, 1, 2, 3, 1],
  [1, 2, 3, 1, 4, 5, 5, 6, 6, 5, 5, 4, 1, 3, 2, 1],
  [0, 1, 3, 1, 4, 4, 5, 5, 5, 5, 4, 4, 1, 3, 1, 0],
  [0, 0, 1, 1, 3, 4, 4, 5, 5, 4, 4, 3, 1, 1, 0, 0],
  [0, 0, 0, 1, 8, 8, 8, 8, 8, 8, 8, 8, 1, 0, 0, 0],
  [0, 0, 0, 1, 3, 3, 4, 4, 4, 4, 3, 3, 1, 0, 0, 0],
  [0, 0, 0, 1, 3, 3, 3, 4, 4, 3, 3, 3, 1, 0, 0, 0],
  [0, 0, 0, 1, 2, 3, 3, 3, 3, 3, 3, 2, 1, 0, 0, 0],
  [0, 0, 0, 1, 2, 2, 3, 3, 3, 3, 2, 2, 1, 0, 0, 0],
  [0, 0, 0, 1, 2, 2, 2, 3, 3, 2, 2, 2, 1, 0, 0, 0],
  [0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0],
  [0, 0, 0, 1, 2, 3, 3, 1, 1, 3, 3, 2, 1, 0, 0, 0],
  [0, 0, 0, 1, 2, 2, 3, 1, 1, 3, 2, 2, 1, 0, 0, 0],
  [0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0],
];

// Heavy sprite: 18 wide x 24 tall
const HEAVY_SPRITE: number[][] = [
  [0, 0, 0, 0, 0, 1, 8, 8, 1, 0, 1, 8, 8, 1, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 1, 8, 1, 0, 1, 8, 1, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 1, 1, 3, 4, 4, 4, 3, 1, 1, 0, 0, 0, 0],
  [0, 0, 0, 0, 1, 3, 4, 5, 5, 5, 5, 5, 4, 3, 1, 0, 0, 0],
  [0, 0, 0, 0, 1, 4, 9, 4, 5, 5, 4, 9, 4, 4, 1, 0, 0, 0],
  [0, 0, 0, 0, 1, 3, 3, 4, 4, 4, 4, 3, 3, 3, 1, 0, 0, 0],
  [0, 0, 0, 0, 0, 1, 3, 2, 3, 3, 2, 3, 1, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0],
  [0, 1, 1, 1, 1, 1, 3, 4, 5, 5, 4, 3, 1, 1, 1, 1, 1, 0],
  [1, 2, 3, 3, 1, 3, 4, 5, 6, 6, 5, 4, 3, 1, 3, 3, 2, 1],
  [1, 2, 2, 3, 1, 4, 5, 6, 6, 6, 6, 5, 4, 1, 3, 2, 2, 1],
  [1, 1, 2, 3, 1, 4, 5, 5, 6, 6, 5, 5, 4, 1, 3, 2, 1, 1],
  [0, 1, 2, 3, 1, 3, 4, 5, 5, 5, 5, 4, 3, 1, 3, 2, 1, 0],
  [0, 0, 1, 1, 1, 3, 4, 4, 5, 5, 4, 4, 3, 1, 1, 1, 0, 0],
  [0, 0, 0, 0, 1, 8, 8, 8, 3, 3, 8, 8, 8, 1, 0, 0, 0, 0],
  [0, 0, 0, 0, 1, 3, 3, 4, 4, 4, 4, 3, 3, 1, 0, 0, 0, 0],
  [0, 0, 0, 0, 1, 3, 3, 3, 4, 4, 3, 3, 3, 1, 0, 0, 0, 0],
  [0, 0, 0, 0, 1, 2, 3, 3, 3, 3, 3, 3, 2, 1, 0, 0, 0, 0],
  [0, 0, 0, 0, 1, 2, 2, 3, 3, 3, 3, 2, 2, 1, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 1, 2, 3, 3, 1, 1, 3, 3, 2, 1, 0, 0, 0, 0],
  [0, 0, 0, 0, 1, 2, 2, 3, 1, 1, 3, 2, 2, 1, 0, 0, 0, 0],
  [0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0],
];

// Boss sprite: 20 wide x 28 tall
const BOSS_SPRITE: number[][] = [
  [0, 0, 0, 1, 8, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 8, 1, 0, 0, 0],
  [0, 0, 0, 0, 1, 8, 1, 0, 1, 8, 8, 1, 0, 1, 8, 1, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 1, 8, 1, 8, 8, 8, 8, 1, 8, 1, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 1, 1, 3, 4, 5, 5, 4, 3, 1, 1, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 1, 3, 4, 5, 6, 6, 6, 6, 5, 4, 3, 1, 0, 0, 0, 0],
  [0, 0, 0, 0, 1, 4, 9, 5, 6, 7, 7, 6, 5, 9, 4, 1, 0, 0, 0, 0],
  [0, 0, 0, 0, 1, 3, 4, 5, 5, 5, 5, 5, 5, 4, 3, 1, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 1, 3, 3, 4, 4, 4, 4, 3, 3, 1, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0],
  [1, 8, 1, 1, 1, 1, 3, 4, 5, 6, 6, 5, 4, 3, 1, 1, 1, 1, 8, 1],
  [0, 1, 8, 1, 1, 3, 4, 5, 6, 7, 7, 6, 5, 4, 3, 1, 1, 8, 1, 0],
  [0, 0, 1, 8, 1, 4, 5, 6, 7, 7, 7, 7, 6, 5, 4, 1, 8, 1, 0, 0],
  [0, 0, 0, 1, 1, 4, 5, 6, 6, 7, 7, 6, 6, 5, 4, 1, 1, 0, 0, 0],
  [0, 0, 0, 1, 3, 4, 5, 5, 6, 6, 6, 6, 5, 5, 4, 3, 1, 0, 0, 0],
  [0, 0, 0, 0, 1, 3, 4, 5, 5, 6, 6, 5, 5, 4, 3, 1, 0, 0, 0, 0],
  [0, 0, 0, 0, 1, 8, 8, 8, 8, 3, 3, 8, 8, 8, 8, 1, 0, 0, 0, 0],
  [0, 0, 0, 0, 1, 3, 3, 4, 4, 5, 5, 4, 4, 3, 3, 1, 0, 0, 0, 0],
  [0, 0, 0, 0, 1, 3, 3, 3, 4, 4, 4, 4, 3, 3, 3, 1, 0, 0, 0, 0],
  [0, 0, 0, 0, 1, 2, 3, 3, 3, 4, 4, 3, 3, 3, 2, 1, 0, 0, 0, 0],
  [0, 0, 0, 0, 1, 2, 2, 3, 3, 3, 3, 3, 3, 2, 2, 1, 0, 0, 0, 0],
  [0, 0, 0, 0, 1, 2, 2, 2, 3, 3, 3, 3, 2, 2, 2, 1, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 1, 2, 3, 3, 3, 1, 1, 3, 3, 3, 2, 1, 0, 0, 0, 0],
  [0, 0, 0, 0, 1, 2, 2, 3, 3, 1, 1, 3, 3, 2, 2, 1, 0, 0, 0, 0],
  [0, 0, 0, 0, 1, 2, 2, 2, 3, 1, 1, 3, 2, 2, 2, 1, 0, 0, 0, 0],
  [0, 0, 0, 0, 1, 1, 2, 2, 3, 1, 1, 3, 2, 2, 1, 1, 0, 0, 0, 0],
  [0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
];

const ENEMY_SPRITES: Record<string, number[][]> = {
  grunt: GRUNT_SPRITE,
  soldier: SOLDIER_SPRITE,
  heavy: HEAVY_SPRITE,
  boss: BOSS_SPRITE,
};

// --------------------------------------------------------------------------
// Pixel sprite drawing utility
// --------------------------------------------------------------------------

function drawPixelSprite(
  ctx: CanvasRenderingContext2D,
  spriteData: number[][],
  palette: [number, number, number][],
  x: number,
  y: number,
  pixelSize: number,
  fogFactor?: number,
  gloveColorOverride?: Record<number, [number, number, number]>,
): void {
  const fog = fogFactor ?? 1;
  for (let row = 0; row < spriteData.length; row++) {
    const rowData = spriteData[row];
    for (let col = 0; col < rowData.length; col++) {
      const palIdx = rowData[col];
      if (palIdx === 0) continue; // transparent
      let color = palette[palIdx];
      if (!color) continue;
      // Apply glove color override for skin tone indices
      if (gloveColorOverride && gloveColorOverride[palIdx]) {
        color = gloveColorOverride[palIdx];
      }
      const r = Math.floor(color[0] * fog);
      const g = Math.floor(color[1] * fog);
      const b = Math.floor(color[2] * fog);
      ctx.fillStyle = `rgb(${r},${g},${b})`;
      ctx.fillRect(
        Math.floor(x + col * pixelSize),
        Math.floor(y + row * pixelSize),
        pixelSize,
        pixelSize,
      );
    }
  }
}

// --------------------------------------------------------------------------
// Star field positions (deterministic, generated once)
// --------------------------------------------------------------------------

const STAR_FIELD: { x: number; y: number; size: number; alpha: number }[] = (() => {
  const stars: { x: number; y: number; size: number; alpha: number }[] = [];
  for (let i = 0; i < 40; i++) {
    const sx = (i * 137 + 53) % SCREEN_W;
    const sy = (i * 97 + 29) % Math.floor(SCREEN_H / 3);
    const sz = i % 4 === 0 ? 2 : 1;
    const sa = 0.08 + ((i * 31) % 10) / 80;
    stars.push({ x: sx, y: sy, size: sz, alpha: sa });
  }
  return stars;
})();

// --------------------------------------------------------------------------
// Weapon definitions
// --------------------------------------------------------------------------

interface WeaponDef {
  name: string;
  damage: number;
  fireRate: number; // ms between shots
  range: number;
  ammoType: string | null; // null = unlimited
  ammoPerShot: number;
  startAmmo: number;
  maxAmmo: number;
  spread: number; // radians, 0 = perfect accuracy
}

const WEAPONS: WeaponDef[] = [
  {
    name: 'Fist',
    damage: 10,
    fireRate: 400,
    range: 1.5,
    ammoType: null,
    ammoPerShot: 0,
    startAmmo: 0,
    maxAmmo: 0,
    spread: 0,
  },
  {
    name: 'Pistol',
    damage: 15,
    fireRate: 350,
    range: 20,
    ammoType: 'bullets',
    ammoPerShot: 1,
    startAmmo: 30,
    maxAmmo: 100,
    spread: 0.01,
  },
  {
    name: 'Shotgun',
    damage: 60,
    fireRate: 800,
    range: 8,
    ammoType: 'shells',
    ammoPerShot: 1,
    startAmmo: 8,
    maxAmmo: 50,
    spread: 0.08,
  },
  {
    name: 'Chaingun',
    damage: 12,
    fireRate: 80,
    range: 18,
    ammoType: 'bullets',
    ammoPerShot: 1,
    startAmmo: 50,
    maxAmmo: 200,
    spread: 0.04,
  },
  {
    name: 'Rocket Launcher',
    damage: 100,
    fireRate: 1200,
    range: 30,
    ammoType: 'rockets',
    ammoPerShot: 1,
    startAmmo: 5,
    maxAmmo: 30,
    spread: 0,
  },
  {
    name: 'BFG',
    damage: 200,
    fireRate: 2000,
    range: 40,
    ammoType: 'cells',
    ammoPerShot: 10,
    startAmmo: 40,
    maxAmmo: 100,
    spread: 0,
  },
];

// --------------------------------------------------------------------------
// Enemy type definitions
// --------------------------------------------------------------------------

interface EnemyTypeDef {
  health: number;
  damage: number;
  speed: number; // units per second
  attackRange: number;
  attackRate: number; // ms between attacks
  score: number;
  color: [number, number, number];
  width: number; // sprite scale multiplier
  height: number;
}

const ENEMY_TYPES: Record<string, EnemyTypeDef> = {
  grunt: {
    health: 30,
    damage: 5,
    speed: 1.2,
    attackRange: 1.5,
    attackRate: 1000,
    score: 50,
    color: [139, 90, 43],
    width: 1,
    height: 1,
  },
  soldier: {
    health: 60,
    damage: 10,
    speed: 1.5,
    attackRange: 10,
    attackRate: 800,
    score: 100,
    color: [100, 110, 130],
    width: 1,
    height: 1,
  },
  heavy: {
    health: 120,
    damage: 20,
    speed: 0.8,
    attackRange: 6,
    attackRate: 1500,
    score: 200,
    color: [160, 40, 40],
    width: 1.3,
    height: 1.2,
  },
  boss: {
    health: 500,
    damage: 30,
    speed: 1.0,
    attackRange: 8,
    attackRate: 1200,
    score: 1000,
    color: [200, 30, 30],
    width: 1.8,
    height: 1.5,
  },
};

// --------------------------------------------------------------------------
// Level data
// --------------------------------------------------------------------------

interface LevelDef {
  name: string;
  map: number[][];
  playerStart: [number, number];
  playerAngle: number;
  exitPos: [number, number];
  enemies: { type: string; x: number; y: number }[];
  pickups: { type: string; x: number; y: number; value: number; weaponName?: string }[];
  secrets: { x: number; y: number }[];
}

// Level 1: Training Facility (16x16)
const LEVEL_1: LevelDef = {
  name: 'Training Facility',
  map: [
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
    [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
    [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
    [1, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 1, 0, 0, 1],
    [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1],
    [1, 0, 0, 0, 0, 0, 1, 1, 1, 5, 1, 1, 1, 0, 0, 1],
    [1, 1, 5, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1],
    [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 1],
    [1, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 1, 1, 1],
    [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
    [1, 0, 0, 1, 1, 5, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1],
    [1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 5, 1, 1, 1],
    [1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1],
    [1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1],
    [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
  ],
  playerStart: [1.5, 1.5],
  playerAngle: 0,
  exitPos: [14.5, 13.5],
  enemies: [
    { type: 'grunt', x: 4.5, y: 3.5 },
    { type: 'grunt', x: 8.5, y: 2.5 },
    { type: 'grunt', x: 8.5, y: 8.5 },
    { type: 'grunt', x: 2.5, y: 9.5 },
    { type: 'grunt', x: 13.5, y: 2.5 },
  ],
  pickups: [
    { type: 'health', x: 1.5, y: 8.5, value: 25 },
    { type: 'ammo_bullets', x: 5.5, y: 1.5, value: 15 },
    { type: 'ammo_bullets', x: 9.5, y: 9.5, value: 15 },
    { type: 'weapon_shotgun', x: 5.5, y: 12.5, value: 0, weaponName: 'Shotgun' },
    { type: 'health', x: 13.5, y: 7.5, value: 25 },
  ],
  secrets: [{ x: 5.5, y: 12.5 }],
};

// Level 2: Demon Base (20x20)
const LEVEL_2: LevelDef = {
  name: 'Demon Base',
  map: [
    [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2],
    [2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2],
    [2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2],
    [2, 0, 0, 0, 0, 5, 0, 0, 3, 3, 3, 3, 0, 0, 5, 0, 0, 0, 0, 2],
    [2, 0, 0, 0, 0, 2, 0, 0, 3, 0, 0, 3, 0, 0, 2, 0, 0, 0, 0, 2],
    [2, 2, 2, 5, 2, 2, 0, 0, 3, 0, 0, 3, 0, 0, 2, 2, 5, 2, 2, 2],
    [2, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 2],
    [2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2],
    [2, 0, 0, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 0, 0, 2],
    [2, 0, 0, 4, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 4, 0, 0, 2],
    [2, 0, 0, 4, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 4, 0, 0, 2],
    [2, 0, 0, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 0, 0, 2],
    [2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2],
    [2, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 2],
    [2, 2, 2, 5, 2, 2, 0, 0, 3, 0, 0, 3, 0, 0, 2, 2, 5, 2, 2, 2],
    [2, 0, 0, 0, 0, 2, 0, 0, 3, 0, 0, 3, 0, 0, 2, 0, 0, 0, 0, 2],
    [2, 0, 0, 0, 0, 5, 0, 0, 3, 3, 3, 3, 0, 0, 5, 0, 0, 0, 0, 2],
    [2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2],
    [2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2],
    [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2],
  ],
  playerStart: [1.5, 1.5],
  playerAngle: Math.PI / 4,
  exitPos: [18.5, 18.5],
  enemies: [
    { type: 'grunt', x: 3.5, y: 7.5 },
    { type: 'grunt', x: 16.5, y: 7.5 },
    { type: 'soldier', x: 9.5, y: 5.5 },
    { type: 'soldier', x: 10.5, y: 5.5 },
    { type: 'grunt', x: 1.5, y: 15.5 },
    { type: 'grunt', x: 18.5, y: 15.5 },
    { type: 'soldier', x: 9.5, y: 12.5 },
    { type: 'soldier', x: 10.5, y: 12.5 },
    { type: 'heavy', x: 9.5, y: 9.5 },
    { type: 'grunt', x: 3.5, y: 17.5 },
  ],
  pickups: [
    { type: 'health', x: 2.5, y: 2.5, value: 25 },
    { type: 'armor', x: 17.5, y: 2.5, value: 30 },
    { type: 'ammo_bullets', x: 7.5, y: 1.5, value: 20 },
    { type: 'ammo_shells', x: 12.5, y: 1.5, value: 10 },
    { type: 'weapon_chaingun', x: 4.5, y: 9.5, value: 0, weaponName: 'Chaingun' },
    { type: 'health', x: 15.5, y: 9.5, value: 50 },
    { type: 'ammo_bullets', x: 9.5, y: 18.5, value: 30 },
    { type: 'armor', x: 1.5, y: 18.5, value: 30 },
    { type: 'health', x: 18.5, y: 1.5, value: 25 },
  ],
  secrets: [
    { x: 4.5, y: 9.5 },
    { x: 15.5, y: 9.5 },
  ],
};

// Level 3: Boss Arena (20x20)
const LEVEL_3: LevelDef = {
  name: 'Boss Arena',
  map: [
    [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2],
    [2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2],
    [2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2],
    [2, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 2],
    [2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2],
    [2, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 2],
    [2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2],
    [2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2],
    [2, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 2],
    [2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2],
    [2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2],
    [2, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 2],
    [2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2],
    [2, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 2],
    [2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2],
    [2, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 2],
    [2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2],
    [2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2],
    [2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2],
    [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2],
  ],
  playerStart: [1.5, 18.5],
  playerAngle: -Math.PI / 4,
  exitPos: [18.5, 1.5],
  enemies: [
    { type: 'boss', x: 10, y: 10 },
    { type: 'soldier', x: 5.5, y: 5.5 },
    { type: 'soldier', x: 14.5, y: 5.5 },
    { type: 'soldier', x: 5.5, y: 14.5 },
    { type: 'soldier', x: 14.5, y: 14.5 },
    { type: 'grunt', x: 10, y: 3.5 },
  ],
  pickups: [
    { type: 'weapon_rocket', x: 10, y: 17.5, value: 0, weaponName: 'Rocket Launcher' },
    { type: 'health', x: 1.5, y: 1.5, value: 50 },
    { type: 'health', x: 18.5, y: 18.5, value: 50 },
    { type: 'armor', x: 18.5, y: 1.5, value: 50 },
    { type: 'ammo_rockets', x: 1.5, y: 10, value: 5 },
    { type: 'ammo_rockets', x: 18.5, y: 10, value: 5 },
    { type: 'ammo_bullets', x: 10, y: 1.5, value: 30 },
    { type: 'ammo_shells', x: 10, y: 18.5, value: 10 },
    { type: 'health', x: 10, y: 5, value: 25 },
    { type: 'health', x: 10, y: 15, value: 25 },
  ],
  secrets: [],
};

// Level 4: The Vault (secret level, requires marketplace key)
const LEVEL_4: LevelDef = {
  name: 'The Vault',
  map: [
    [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
    [3, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 3],
    [3, 0, 0, 0, 3, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 3],
    [3, 0, 0, 0, 3, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 3],
    [3, 0, 3, 3, 3, 0, 0, 0, 0, 0, 3, 3, 3, 0, 0, 3],
    [3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3],
    [3, 0, 0, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0, 0, 0, 3],
    [3, 5, 0, 0, 0, 0, 4, 0, 0, 4, 0, 0, 0, 0, 5, 3],
    [3, 0, 0, 0, 0, 0, 4, 0, 0, 4, 0, 0, 0, 0, 0, 3],
    [3, 0, 0, 0, 0, 0, 4, 4, 5, 4, 0, 0, 0, 0, 0, 3],
    [3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3],
    [3, 0, 3, 3, 3, 0, 0, 0, 0, 0, 3, 3, 3, 0, 0, 3],
    [3, 0, 0, 0, 3, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 3],
    [3, 0, 0, 0, 3, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 3],
    [3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3],
    [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
  ],
  playerStart: [1.5, 14.5],
  playerAngle: -Math.PI / 2,
  exitPos: [14.5, 1.5],
  enemies: [
    { type: 'heavy', x: 7.5, y: 7.5 },
    { type: 'heavy', x: 8.5, y: 8.5 },
    { type: 'soldier', x: 3.5, y: 3.5 },
    { type: 'soldier', x: 12.5, y: 3.5 },
    { type: 'soldier', x: 3.5, y: 12.5 },
    { type: 'soldier', x: 12.5, y: 12.5 },
    { type: 'boss', x: 7.5, y: 1.5 },
  ],
  pickups: [
    { type: 'weapon_rocket', x: 1.5, y: 7.5, value: 0, weaponName: 'Rocket Launcher' },
    { type: 'weapon_bfg', x: 14.5, y: 7.5, value: 0, weaponName: 'BFG' },
    { type: 'health', x: 7.5, y: 14.5, value: 50 },
    { type: 'health', x: 8.5, y: 14.5, value: 50 },
    { type: 'armor', x: 7.5, y: 5.5, value: 50 },
    { type: 'ammo_rockets', x: 4.5, y: 7.5, value: 10 },
    { type: 'ammo_cells', x: 11.5, y: 7.5, value: 30 },
    { type: 'ammo_bullets', x: 7.5, y: 10.5, value: 50 },
  ],
  secrets: [{ x: 7.5, y: 7.5 }],
};

const LEVELS: LevelDef[] = [LEVEL_1, LEVEL_2, LEVEL_3, LEVEL_4];

// --------------------------------------------------------------------------
// Mutable game state
// --------------------------------------------------------------------------

interface EnemyState {
  id: number;
  x: number;
  y: number;
  health: number;
  maxHealth: number;
  type: string;
  state: 'idle' | 'alert' | 'chasing' | 'attacking' | 'dead';
  alive: boolean;
  lastAttack: number;
  alertTimer: number;
  lostSightTimer: number;
}

interface PickupState {
  id: number;
  x: number;
  y: number;
  type: string;
  value: number;
  collected: boolean;
  weaponName?: string;
}

interface SecretState {
  x: number;
  y: number;
  found: boolean;
}

interface WeaponState {
  name: string;
  owned: boolean;
  ammo: number;
  maxAmmo: number;
  damage: number;
  fireRate: number;
  ammoType: string | null;
  ammoPerShot: number;
  range: number;
  spread: number;
}

interface FPSGameState {
  playerX: number;
  playerY: number;
  playerAngle: number;
  playerHealth: number;
  playerArmor: number;
  weapons: WeaponState[];
  currentWeapon: number;
  enemies: EnemyState[];
  pickups: PickupState[];
  map: number[][];
  mapWidth: number;
  mapHeight: number;
  level: number;
  exitX: number;
  exitY: number;
  secrets: SecretState[];
  score: number;
  kills: number;
  secretsFound: number;
  totalSecrets: number;
  gameTime: number;
  message: string | null;
  messageTimer: number;
  screenFlash: string | null;
  flashTimer: number;
  weaponBob: number;
  weaponRecoil: number;
  lastShotTime: number;
  gameOver: boolean;
  victory: boolean;
  levelTransition: boolean;
  levelTransitionTimer: number;
  gloveColor: string;
  lastEnemyAIUpdate: number;
  // Particle system
  particles: Particle[];
  // Kill feed
  killFeed: KillFeedEntry[];
  // Screen shake
  shakeTimer: number;
  shakeIntensity: number;
  // Damage vignette
  damageVignetteTimer: number;
  // Pickup flash
  pickupFlashColor: string | null;
  pickupFlashTimer: number;
  // Consumables
  consumables: ConsumableState[];
  damageBoostTimer: number;
  invincibilityTimer: number;
  extraLives: number;
  // Multiplayer state
  multiplayerMode: boolean;
  matchId: string | null;
  matchStatus: 'connecting' | 'waiting' | 'countdown' | 'playing' | 'ended';
  countdownSeconds: number;
  wsRef: WebSocket | null;
  remotePlayers: Map<string, RemotePlayer>;
  localPlayerId: string;
  matchScores: Record<string, { kills: number; deaths: number; name: string }>;
  killsToWin: number;
  lastNetworkUpdate: number;
  mpWaitingPlayers: number;
  mpMaxPlayers: number;
  mpReady: boolean;
  mpWinnerId: string | null;
  mpKilledBy: string | null;
  mpRespawnTimer: number;
  mpMatchDuration: number;
  // Weapon ownership from marketplace
  ownedWeapons: string[];
  secretLevelUnlocked: boolean;
  // Max available level (3 base + optional vault)
  maxLevel: number;
}

// --------------------------------------------------------------------------
// Utility functions
// --------------------------------------------------------------------------

function dist(x1: number, y1: number, x2: number, y2: number): number {
  const dx = x2 - x1;
  const dy = y2 - y1;
  return Math.sqrt(dx * dx + dy * dy);
}

function clamp(v: number, min: number, max: number): number {
  return v < min ? min : v > max ? max : v;
}

function darkenRGB(r: number, g: number, b: number, factor: number): [number, number, number] {
  return [Math.floor(r * factor), Math.floor(g * factor), Math.floor(b * factor)];
}

// Check line of sight between two points on the map
function hasLineOfSight(
  x1: number,
  y1: number,
  x2: number,
  y2: number,
  map: number[][],
  mapWidth: number,
  mapHeight: number,
): boolean {
  const dx = x2 - x1;
  const dy = y2 - y1;
  const distance = Math.sqrt(dx * dx + dy * dy);
  const steps = Math.ceil(distance * 4);
  for (let i = 0; i <= steps; i++) {
    const t = i / steps;
    const cx = x1 + dx * t;
    const cy = y1 + dy * t;
    const mx = Math.floor(cx);
    const my = Math.floor(cy);
    if (mx < 0 || mx >= mapWidth || my < 0 || my >= mapHeight) return false;
    if (map[my][mx] > 0) return false;
  }
  return true;
}

// Spawn particles at a screen position
function spawnParticles(
  particles: Particle[],
  x: number,
  y: number,
  count: number,
  color: string,
  speedRange: number,
  lifeRange: number,
  sizeRange: number,
): void {
  for (let i = 0; i < count; i++) {
    const angle = Math.random() * Math.PI * 2;
    const speed = Math.random() * speedRange + speedRange * 0.3;
    particles.push({
      x,
      y,
      vx: Math.cos(angle) * speed,
      vy: Math.sin(angle) * speed - Math.random() * 2,
      life: lifeRange * (0.5 + Math.random() * 0.5),
      maxLife: lifeRange,
      color,
      size: 1 + Math.random() * sizeRange,
    });
  }
}

// Multiplayer: get WebSocket URL
function getWsUrl(): string {
  if (typeof window === 'undefined') return '';
  const apiUrl = process.env.NEXT_PUBLIC_API_URL || '';
  if (apiUrl) {
    try {
      const url = new URL(apiUrl);
      const protocol = url.protocol === 'https:' ? 'wss:' : 'ws:';
      return `${protocol}//${url.host}`;
    } catch {
      // fall through to window.location
    }
  }
  const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
  const host = window.location.hostname;
  const port = window.location.hostname === 'localhost' ? ':3001' : '';
  return `${protocol}//${host}${port}`;
}

// --------------------------------------------------------------------------
// Build initial game state from a level
// --------------------------------------------------------------------------

function buildLevelState(
  levelIndex: number,
  carryOver?: {
    health: number;
    armor: number;
    weapons: WeaponState[];
    score: number;
    kills: number;
    secretsFound: number;
    gameTime: number;
  },
  gloveColor?: string,
  configOptions?: {
    ownedWeapons?: string[];
    secretLevelUnlocked?: boolean;
    consumables?: { type: string; count: number }[];
    multiplayer?: boolean;
    matchId?: string;
    difficulty?: string;
    killsToWin?: number;
  },
): FPSGameState {
  const actualIndex = Math.min(levelIndex, LEVELS.length - 1);
  const level = LEVELS[actualIndex];
  const map = level.map.map((row) => [...row]);
  const mapHeight = map.length;
  const mapWidth = map[0].length;

  const difficultyMult =
    configOptions?.difficulty === 'easy' ? 0.7 : configOptions?.difficulty === 'hard' ? 1.5 : 1.0;

  const weapons: WeaponState[] = WEAPONS.map((w, i) => ({
    name: w.name,
    owned: i <= 1, // fist and pistol owned by default
    ammo: w.ammoType === null ? Infinity : w.startAmmo,
    maxAmmo: w.maxAmmo,
    damage: w.damage,
    fireRate: w.fireRate,
    ammoType: w.ammoType,
    ammoPerShot: w.ammoPerShot,
    range: w.range,
    spread: w.spread,
  }));

  const enemies: EnemyState[] = level.enemies.map((e, i) => {
    const def = ENEMY_TYPES[e.type];
    return {
      id: i,
      x: e.x,
      y: e.y,
      health: Math.floor(def.health * difficultyMult),
      maxHealth: Math.floor(def.health * difficultyMult),
      type: e.type,
      state: 'idle' as const,
      alive: true,
      lastAttack: 0,
      alertTimer: 0,
      lostSightTimer: 0,
    };
  });

  const pickups: PickupState[] = level.pickups.map((p, i) => ({
    id: i,
    x: p.x,
    y: p.y,
    type: p.type,
    value: p.value,
    collected: false,
    weaponName: p.weaponName,
  }));

  const secrets: SecretState[] = level.secrets.map((s) => ({
    x: s.x,
    y: s.y,
    found: false,
  }));

  // Parse consumables from config
  const consumables: ConsumableState[] = [];
  let extraLives = 0;
  if (configOptions?.consumables) {
    for (const c of configOptions.consumables) {
      if (c.type === 'extra_life') {
        extraLives = c.count;
      } else {
        consumables.push({ type: c.type, count: c.count });
      }
    }
  }

  const ownedWeapons = configOptions?.ownedWeapons || [];
  const secretLevelUnlocked = configOptions?.secretLevelUnlocked || false;
  const isMultiplayer = configOptions?.multiplayer || false;

  const state: FPSGameState = {
    playerX: level.playerStart[0],
    playerY: level.playerStart[1],
    playerAngle: level.playerAngle,
    playerHealth: carryOver ? carryOver.health : 100,
    playerArmor: carryOver ? carryOver.armor : 0,
    weapons: carryOver ? carryOver.weapons.map((w) => ({ ...w })) : weapons,
    currentWeapon: 1,
    enemies,
    pickups,
    map,
    mapWidth,
    mapHeight,
    level: actualIndex,
    exitX: level.exitPos[0],
    exitY: level.exitPos[1],
    secrets,
    score: carryOver ? carryOver.score : 0,
    kills: carryOver ? carryOver.kills : 0,
    secretsFound: carryOver ? carryOver.secretsFound : 0,
    totalSecrets: secrets.length + (carryOver ? carryOver.secretsFound : 0),
    gameTime: carryOver ? carryOver.gameTime : 0,
    message: `Level ${actualIndex + 1}: ${level.name}`,
    messageTimer: 3000,
    screenFlash: null,
    flashTimer: 0,
    weaponBob: 0,
    weaponRecoil: 0,
    lastShotTime: 0,
    gameOver: false,
    victory: false,
    levelTransition: false,
    levelTransitionTimer: 0,
    gloveColor: gloveColor || 'default',
    lastEnemyAIUpdate: 0,
    // Particle system
    particles: [],
    // Kill feed
    killFeed: [],
    // Screen shake
    shakeTimer: 0,
    shakeIntensity: 0,
    // Damage vignette
    damageVignetteTimer: 0,
    // Pickup flash
    pickupFlashColor: null,
    pickupFlashTimer: 0,
    // Consumables
    consumables,
    damageBoostTimer: 0,
    invincibilityTimer: 0,
    extraLives,
    // Multiplayer
    multiplayerMode: isMultiplayer,
    matchId: configOptions?.matchId || null,
    matchStatus: isMultiplayer ? 'connecting' : 'playing',
    countdownSeconds: 0,
    wsRef: null,
    remotePlayers: new Map(),
    localPlayerId: '',
    matchScores: {},
    killsToWin: configOptions?.killsToWin || 10,
    lastNetworkUpdate: 0,
    mpWaitingPlayers: 0,
    mpMaxPlayers: 4,
    mpReady: false,
    mpWinnerId: null,
    mpKilledBy: null,
    mpRespawnTimer: 0,
    mpMatchDuration: 0,
    // Marketplace
    ownedWeapons,
    secretLevelUnlocked,
    maxLevel: secretLevelUnlocked ? 3 : 2, // 0-indexed: levels 0,1,2 base + level 3 if unlocked
  };

  return state;
}

// ==========================================================================
// Component
// ==========================================================================

export default function FPSRenderer({ gameConfig: config }: FPSRendererProps) {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const stateRef = useRef<FPSGameState | null>(null);
  const keysRef = useRef<Set<string>>(new Set());
  const rafRef = useRef<number>(0);
  const lastTimeRef = useRef<number>(0);
  const zBufferRef = useRef<Float64Array>(new Float64Array(SCREEN_W));
  const pointerLockedRef = useRef(false);
  const wsRef = useRef<WebSocket | null>(null);

  const [started, setStarted] = useState(false);
  const [showControls, setShowControls] = useState(true);

  // Initialize game
  const initGame = useCallback(
    (levelIndex = 0, carryOver?: FPSGameState) => {
      const glove = (config?.equippedGlove as string) || 'default';
      const carry = carryOver
        ? {
            health: carryOver.playerHealth,
            armor: carryOver.playerArmor,
            weapons: carryOver.weapons,
            score: carryOver.score,
            kills: carryOver.kills,
            secretsFound: carryOver.secretsFound,
            gameTime: carryOver.gameTime,
          }
        : undefined;

      const configOptions = {
        ownedWeapons: (config?.ownedWeapons as string[]) || [],
        secretLevelUnlocked: (config?.secretLevelUnlocked as boolean) || false,
        consumables: (config?.consumables as { type: string; count: number }[]) || [],
        multiplayer: (config?.multiplayer as boolean) || false,
        matchId: (config?.matchId as string) || undefined,
        difficulty: (config?.difficulty as string) || 'normal',
        killsToWin: 10,
      };

      stateRef.current = buildLevelState(levelIndex, carry, glove, configOptions);
      lastTimeRef.current = 0;

      // Apply marketplace weapon ownership: only allow owned weapons beyond pistol/fist
      if (configOptions.ownedWeapons.length > 0 && stateRef.current) {
        const gs = stateRef.current;
        const weaponSlugMap: Record<string, number> = {
          shotgun: 2,
          chaingun: 3,
          rocket_launcher: 4,
          bfg: 5,
        };
        for (let i = 2; i < gs.weapons.length; i++) {
          // Only mark as owned if in ownedWeapons or found as pickup
          // On init, just mark marketplace-owned weapons
          const slug = Object.keys(weaponSlugMap).find((k) => weaponSlugMap[k] === i);
          if (slug && configOptions.ownedWeapons.includes(slug)) {
            // Weapon is purchasable, mark ownership is available (will be picked up or already owned)
            // Don't auto-own, but allow switching to it if found
          }
        }
      }
    },
    [config],
  );

  // -----------------------------------------------------------------------
  // Multiplayer WebSocket setup
  // -----------------------------------------------------------------------

  const setupMultiplayer = useCallback((gs: FPSGameState) => {
    if (!gs.multiplayerMode || !gs.matchId) return;

    const wsUrl = getWsUrl();
    if (!wsUrl) return;

    const ws = new WebSocket(wsUrl);
    wsRef.current = ws;
    gs.wsRef = ws;

    ws.onopen = () => {
      gs.matchStatus = 'connecting';
      // Authenticate
      const token = typeof window !== 'undefined' ? localStorage.getItem('moltblox_token') : null;
      if (token) {
        ws.send(JSON.stringify({ type: 'authenticate', payload: { token } }));
      }
    };

    ws.onmessage = (event) => {
      try {
        const msg = JSON.parse(event.data);
        handleMultiplayerMessage(gs, msg);
      } catch {
        // Ignore unparseable messages
      }
    };

    ws.onclose = () => {
      wsRef.current = null;
      gs.wsRef = null;
      if (gs.matchStatus === 'playing') {
        gs.message = 'DISCONNECTED';
        gs.messageTimer = 5000;
      }
    };

    ws.onerror = () => {
      gs.message = 'CONNECTION ERROR';
      gs.messageTimer = 3000;
    };
  }, []);

  const handleMultiplayerMessage = useCallback(
    (gs: FPSGameState, msg: { type: string; payload: Record<string, unknown> }) => {
      switch (msg.type) {
        case 'authenticated': {
          // Join the match
          if (gs.matchId) {
            gs.wsRef?.send(
              JSON.stringify({ type: 'fps_join_match', payload: { matchId: gs.matchId } }),
            );
          }
          break;
        }

        case 'fps_match_created': {
          gs.matchId = msg.payload.matchId as string;
          gs.matchStatus = 'waiting';
          gs.message = 'MATCH CREATED. WAITING FOR PLAYERS...';
          gs.messageTimer = 5000;
          break;
        }

        case 'fps_player_joined': {
          const playerId = msg.payload.playerId as string;
          const playerName = msg.payload.name as string;
          gs.mpWaitingPlayers = msg.payload.playerCount as number;
          gs.mpMaxPlayers = msg.payload.maxPlayers as number;
          gs.matchStatus = 'waiting';

          if (!gs.localPlayerId) {
            gs.localPlayerId = playerId;
          }

          if (!gs.remotePlayers.has(playerId) && playerId !== gs.localPlayerId) {
            gs.remotePlayers.set(playerId, {
              id: playerId,
              name: playerName,
              x: 0,
              y: 0,
              angle: 0,
              health: 100,
              weaponIndex: 1,
              alive: true,
              prevX: 0,
              prevY: 0,
              prevAngle: 0,
              lastUpdate: Date.now(),
            });
          }

          gs.killFeed.push({
            text: `${playerName} joined`,
            time: Date.now(),
            color: '#4488ff',
          });
          break;
        }

        case 'fps_countdown': {
          gs.matchStatus = 'countdown';
          gs.countdownSeconds = msg.payload.seconds as number;
          break;
        }

        case 'fps_match_start': {
          gs.matchStatus = 'playing';
          const players = msg.payload.players as {
            id: string;
            name: string;
            spawnX: number;
            spawnY: number;
            spawnAngle: number;
          }[];
          for (const p of players) {
            if (p.id === gs.localPlayerId) {
              gs.playerX = p.spawnX;
              gs.playerY = p.spawnY;
              gs.playerAngle = p.spawnAngle;
            } else {
              const existing = gs.remotePlayers.get(p.id);
              if (existing) {
                existing.x = p.spawnX;
                existing.y = p.spawnY;
                existing.angle = p.spawnAngle;
                existing.prevX = p.spawnX;
                existing.prevY = p.spawnY;
                existing.prevAngle = p.spawnAngle;
                existing.lastUpdate = Date.now();
                existing.alive = true;
                existing.health = 100;
              } else {
                gs.remotePlayers.set(p.id, {
                  id: p.id,
                  name: p.name,
                  x: p.spawnX,
                  y: p.spawnY,
                  angle: p.spawnAngle,
                  health: 100,
                  weaponIndex: 1,
                  alive: true,
                  prevX: p.spawnX,
                  prevY: p.spawnY,
                  prevAngle: p.spawnAngle,
                  lastUpdate: Date.now(),
                });
              }
              // Initialize scores
              gs.matchScores[p.id] = { kills: 0, deaths: 0, name: p.name };
            }
            gs.matchScores[gs.localPlayerId] = gs.matchScores[gs.localPlayerId] || {
              kills: 0,
              deaths: 0,
              name: 'You',
            };
          }
          gs.message = 'FIGHT!';
          gs.messageTimer = 2000;
          break;
        }

        case 'fps_state': {
          const players = msg.payload.players as {
            id: string;
            x: number;
            y: number;
            angle: number;
            health: number;
            weaponIndex: number;
            alive: boolean;
          }[];
          for (const p of players) {
            if (p.id === gs.localPlayerId) continue;
            const remote = gs.remotePlayers.get(p.id);
            if (remote) {
              remote.prevX = remote.x;
              remote.prevY = remote.y;
              remote.prevAngle = remote.angle;
              remote.x = p.x;
              remote.y = p.y;
              remote.angle = p.angle;
              remote.health = p.health;
              remote.weaponIndex = p.weaponIndex;
              remote.alive = p.alive;
              remote.lastUpdate = Date.now();
            }
          }
          break;
        }

        case 'fps_player_shot': {
          const shooterId = msg.payload.playerId as string;
          if (shooterId !== gs.localPlayerId) {
            const remote = gs.remotePlayers.get(shooterId);
            if (remote) {
              // Spawn muzzle flash particles at remote player screen position (approximate)
              spawnParticles(gs.particles, SCREEN_W / 2, SCREEN_H / 2, 2, '#ffff44', 3, 100, 2);
            }
          }
          break;
        }

        case 'fps_player_hit': {
          const targetId = msg.payload.targetId as string;
          const newHealth = msg.payload.newHealth as number;
          if (targetId === gs.localPlayerId) {
            gs.playerHealth = newHealth;
            gs.screenFlash = 'red';
            gs.flashTimer = 150;
            gs.damageVignetteTimer = 200;
            gs.shakeTimer = 150;
            gs.shakeIntensity = 3;
            spawnParticles(
              gs.particles,
              Math.random() * SCREEN_W,
              Math.random() < 0.5 ? 0 : SCREEN_H,
              4,
              '#ff3333',
              4,
              300,
              3,
            );
          } else {
            const remote = gs.remotePlayers.get(targetId);
            if (remote) {
              remote.health = newHealth;
            }
          }
          break;
        }

        case 'fps_player_killed': {
          const victimId = msg.payload.victimId as string;
          const killerId = msg.payload.killerId as string;
          const weapon = msg.payload.weapon as string;
          const killerName = gs.matchScores[killerId]?.name || 'Unknown';
          const victimName = gs.matchScores[victimId]?.name || 'Unknown';

          gs.killFeed.push({
            text: `${killerName} [${weapon}] ${victimName}`,
            time: Date.now(),
            color:
              killerId === gs.localPlayerId
                ? '#22cc22'
                : victimId === gs.localPlayerId
                  ? '#cc2222'
                  : '#dddddd',
          });

          if (victimId === gs.localPlayerId) {
            gs.mpKilledBy = killerName;
            gs.mpRespawnTimer = 3000;
            gs.playerHealth = 0;
            // Death particles
            spawnParticles(gs.particles, SCREEN_W / 2, SCREEN_H / 2, 10, '#cc0000', 6, 500, 4);
          } else {
            const remote = gs.remotePlayers.get(victimId);
            if (remote) {
              remote.alive = false;
            }
          }
          break;
        }

        case 'fps_player_respawned': {
          const respawnId = msg.payload.playerId as string;
          if (respawnId === gs.localPlayerId) {
            gs.playerX = msg.payload.x as number;
            gs.playerY = msg.payload.y as number;
            gs.playerAngle = msg.payload.angle as number;
            gs.playerHealth = 100;
            gs.mpKilledBy = null;
            gs.mpRespawnTimer = 0;
            gs.screenFlash = 'yellow';
            gs.flashTimer = 200;
          } else {
            const remote = gs.remotePlayers.get(respawnId);
            if (remote) {
              remote.x = msg.payload.x as number;
              remote.y = msg.payload.y as number;
              remote.angle = msg.payload.angle as number;
              remote.prevX = remote.x;
              remote.prevY = remote.y;
              remote.prevAngle = remote.angle;
              remote.health = 100;
              remote.alive = true;
              remote.lastUpdate = Date.now();
            }
          }
          break;
        }

        case 'fps_score_update': {
          const scores = msg.payload.scores as Record<string, { kills: number; deaths: number }>;
          for (const [id, s] of Object.entries(scores)) {
            if (gs.matchScores[id]) {
              gs.matchScores[id].kills = s.kills;
              gs.matchScores[id].deaths = s.deaths;
            }
          }
          break;
        }

        case 'fps_match_end': {
          gs.matchStatus = 'ended';
          gs.mpWinnerId = msg.payload.winnerId as string;
          gs.mpMatchDuration = msg.payload.duration as number;
          const finalScores = msg.payload.scores as Record<
            string,
            { kills: number; deaths: number }
          >;
          for (const [id, s] of Object.entries(finalScores)) {
            if (gs.matchScores[id]) {
              gs.matchScores[id].kills = s.kills;
              gs.matchScores[id].deaths = s.deaths;
            }
          }
          break;
        }

        case 'fps_player_left': {
          const leftId = msg.payload.playerId as string;
          const leftPlayer = gs.remotePlayers.get(leftId);
          if (leftPlayer) {
            gs.killFeed.push({
              text: `${leftPlayer.name} left`,
              time: Date.now(),
              color: '#888888',
            });
            gs.remotePlayers.delete(leftId);
          }
          break;
        }

        default:
          break;
      }
    },
    [],
  );

  // -----------------------------------------------------------------------
  // Shooting
  // -----------------------------------------------------------------------

  const shootWeapon = useCallback((gs: FPSGameState, now: number) => {
    const w = gs.weapons[gs.currentWeapon];
    if (!w.owned) return;

    // Check fire rate
    if (now - gs.lastShotTime < w.fireRate) return;

    // Check ammo
    if (w.ammoType !== null) {
      if (w.ammo < w.ammoPerShot) return;
      w.ammo -= w.ammoPerShot;
    }

    gs.lastShotTime = now;
    gs.weaponRecoil = 10;

    // Muzzle flash
    gs.screenFlash = 'yellow';
    gs.flashTimer = 50;

    // Muzzle flash particles
    const muzzleX = SCREEN_W / 2;
    const muzzleY = SCREEN_H - 180;
    spawnParticles(gs.particles, muzzleX, muzzleY, 3, '#ffff88', 4, 80, 2);

    // Apply damage boost
    const dmgMult = gs.damageBoostTimer > 0 ? 2 : 1;

    // Ray from player in look direction (with spread)
    const spreadOffset = (Math.random() - 0.5) * w.spread * 2;
    const rayAngle = gs.playerAngle + spreadOffset;
    const rayDirX = Math.cos(rayAngle);
    const rayDirY = Math.sin(rayAngle);

    // Multiplayer hit detection
    if (gs.multiplayerMode && gs.matchStatus === 'playing') {
      let closestMpDist = w.range;
      let closestMpTarget: RemotePlayer | null = null;

      gs.remotePlayers.forEach((remote) => {
        if (!remote.alive) return;
        const dx = remote.x - gs.playerX;
        const dy = remote.y - gs.playerY;
        const d = Math.sqrt(dx * dx + dy * dy);
        if (d > w.range || d > closestMpDist) return;

        const dot = dx * rayDirX + dy * rayDirY;
        if (dot <= 0) return;

        const perpX = dx - dot * rayDirX;
        const perpY = dy - dot * rayDirY;
        const perpDist = Math.sqrt(perpX * perpX + perpY * perpY);

        if (perpDist < 0.4) {
          if (
            hasLineOfSight(
              gs.playerX,
              gs.playerY,
              remote.x,
              remote.y,
              gs.map,
              gs.mapWidth,
              gs.mapHeight,
            )
          ) {
            closestMpDist = dot;
            closestMpTarget = remote;
          }
        }
      });

      if (closestMpTarget) {
        const falloff = 1 - (closestMpDist / w.range) * 0.5;
        const damage = Math.floor(w.damage * falloff * dmgMult);
        gs.wsRef?.send(
          JSON.stringify({
            type: 'fps_hit',
            payload: { targetId: (closestMpTarget as RemotePlayer).id, damage },
          }),
        );
      }

      // Also send shoot event
      gs.wsRef?.send(
        JSON.stringify({
          type: 'fps_shoot',
          payload: { angle: gs.playerAngle, weaponIndex: gs.currentWeapon },
        }),
      );
    }

    // Single-player hit detection (always active for PvE enemies)
    let closestDist = w.range;
    let closestEnemy: EnemyState | null = null;

    for (const enemy of gs.enemies) {
      if (!enemy.alive) continue;

      const dx = enemy.x - gs.playerX;
      const dy = enemy.y - gs.playerY;
      const d = Math.sqrt(dx * dx + dy * dy);
      if (d > w.range || d > closestDist) continue;

      // Project enemy onto ray
      const dot = dx * rayDirX + dy * rayDirY;
      if (dot <= 0) continue; // behind player

      // Perpendicular distance from ray to enemy center
      const perpX = dx - dot * rayDirX;
      const perpY = dy - dot * rayDirY;
      const perpDist = Math.sqrt(perpX * perpX + perpY * perpY);

      const hitRadius = 0.4 * (ENEMY_TYPES[enemy.type]?.width || 1);
      if (perpDist < hitRadius) {
        // Check line of sight
        if (
          hasLineOfSight(
            gs.playerX,
            gs.playerY,
            enemy.x,
            enemy.y,
            gs.map,
            gs.mapWidth,
            gs.mapHeight,
          )
        ) {
          closestDist = dot;
          closestEnemy = enemy;
        }
      }
    }

    if (closestEnemy) {
      // Distance falloff: full damage at close range, 50% at max range
      const falloff = 1 - (closestDist / w.range) * 0.5;
      const damage = Math.floor(w.damage * falloff * dmgMult);
      closestEnemy.health -= damage;

      if (closestEnemy.state === 'idle') {
        closestEnemy.state = 'alert';
        closestEnemy.alertTimer = 1000;
      }

      if (closestEnemy.health <= 0) {
        closestEnemy.health = 0;
        closestEnemy.alive = false;
        closestEnemy.state = 'dead';
        gs.kills++;
        const scoreDef = ENEMY_TYPES[closestEnemy.type];
        gs.score += scoreDef ? scoreDef.score : 50;

        // Death particles (at approximate screen position)
        spawnParticles(gs.particles, SCREEN_W / 2, SCREEN_H / 2, 10, '#aa2222', 5, 400, 3);
        spawnParticles(gs.particles, SCREEN_W / 2, SCREEN_H / 2, 4, '#661111', 3, 300, 2);

        // Kill feed
        gs.killFeed.push({
          text: `You killed ${closestEnemy.type} with ${w.name}`,
          time: Date.now(),
          color: '#22cc22',
        });
      }
    }
  }, []);

  // -----------------------------------------------------------------------
  // Game loop
  // -----------------------------------------------------------------------

  const gameLoop = useCallback(
    (timestamp: number) => {
      rafRef.current = requestAnimationFrame(gameLoop);

      const gs = stateRef.current;
      if (!gs || !started) return;

      // Delta time
      if (lastTimeRef.current === 0) lastTimeRef.current = timestamp;
      const dt = Math.min((timestamp - lastTimeRef.current) / 1000, 0.05);
      lastTimeRef.current = timestamp;

      if (gs.gameOver || gs.victory) {
        render(gs);
        return;
      }

      // Multiplayer: waiting / countdown / ended states
      if (gs.multiplayerMode && gs.matchStatus !== 'playing') {
        // Still render the scene but don't process movement
        if (gs.matchStatus === 'ended') {
          render(gs);
          return;
        }
        render(gs);
        return;
      }

      // Level transition
      if (gs.levelTransition) {
        gs.levelTransitionTimer -= dt * 1000;
        if (gs.levelTransitionTimer <= 0) {
          const nextLevel = gs.level + 1;
          // Check if next level is the vault (level 3) and requires unlock
          if (nextLevel === 3 && !gs.secretLevelUnlocked) {
            gs.victory = true;
            gs.levelTransition = false;
          } else if (nextLevel >= LEVELS.length) {
            gs.victory = true;
            gs.levelTransition = false;
          } else {
            initGame(nextLevel, gs);
          }
        }
        render(gs);
        return;
      }

      const now = timestamp;
      const keys = keysRef.current;

      // ---- Player movement ----
      // Skip movement if dead in multiplayer (respawn timer)
      if (gs.multiplayerMode && gs.mpRespawnTimer > 0) {
        gs.mpRespawnTimer -= dt * 1000;
        if (gs.mpRespawnTimer <= 0) {
          gs.wsRef?.send(JSON.stringify({ type: 'fps_respawn' }));
        }
        // Update particles and timers, then render
        updateParticlesAndTimers(gs, dt);
        render(gs);
        return;
      }

      const running = keys.has('shift') || keys.has('shiftleft') || keys.has('shiftright');
      const speed = MOVE_SPEED * (running ? RUN_MULTIPLIER : 1) * dt;

      const dirX = Math.cos(gs.playerAngle);
      const dirY = Math.sin(gs.playerAngle);
      const perpX = -dirY;
      const perpY = dirX;

      let moveX = 0;
      let moveY = 0;

      if (keys.has('w') || keys.has('arrowup')) {
        moveX += dirX * speed;
        moveY += dirY * speed;
      }
      if (keys.has('s') || keys.has('arrowdown')) {
        moveX -= dirX * speed;
        moveY -= dirY * speed;
      }
      if (keys.has('a')) {
        moveX += perpX * speed;
        moveY += perpY * speed;
      }
      if (keys.has('d')) {
        moveX -= perpX * speed;
        moveY -= perpY * speed;
      }

      // Keyboard turning
      if (keys.has('arrowleft')) {
        gs.playerAngle -= TURN_SPEED * dt;
      }
      if (keys.has('arrowright')) {
        gs.playerAngle += TURN_SPEED * dt;
      }

      // Collision detection with wall sliding
      if (moveX !== 0 || moveY !== 0) {
        const newX = gs.playerX + moveX;
        const newY = gs.playerY + moveY;
        const r = PLAYER_RADIUS;

        const canMoveX =
          gs.map[Math.floor(gs.playerY)][Math.floor(newX + r)] === 0 &&
          gs.map[Math.floor(gs.playerY)][Math.floor(newX - r)] === 0;
        const canMoveY =
          gs.map[Math.floor(newY + r)][Math.floor(gs.playerX)] === 0 &&
          gs.map[Math.floor(newY - r)][Math.floor(gs.playerX)] === 0;
        const canMoveBoth =
          gs.map[Math.floor(newY + r)][Math.floor(newX + r)] === 0 &&
          gs.map[Math.floor(newY - r)][Math.floor(newX - r)] === 0 &&
          gs.map[Math.floor(newY + r)][Math.floor(newX - r)] === 0 &&
          gs.map[Math.floor(newY - r)][Math.floor(newX + r)] === 0;

        if (canMoveX && canMoveY && canMoveBoth) {
          gs.playerX = newX;
          gs.playerY = newY;
        } else if (canMoveX) {
          gs.playerX = newX;
        } else if (canMoveY) {
          gs.playerY = newY;
        }

        // Weapon bob when moving
        gs.weaponBob += dt * 8;
      }

      // Shooting (space or mouse tracked via pointerdown flag)
      if (keys.has(' ') || keys.has('shooting')) {
        shootWeapon(gs, now);
      }

      // Weapon switching (check ownership)
      for (let i = 1; i <= 6; i++) {
        if (keys.has(String(i))) {
          const weaponIdx = i - 1;
          if (gs.weapons[weaponIdx] && gs.weapons[weaponIdx].owned) {
            gs.currentWeapon = weaponIdx;
          }
        }
      }

      // Consumable usage (Q key)
      if (keys.has('q')) {
        keys.delete('q'); // One-shot
        useConsumable(gs);
      }

      // Door interaction (E or F key)
      if (keys.has('e') || keys.has('f')) {
        keys.delete('e');
        keys.delete('f');
        // Check the cell the player is facing, 1 unit ahead
        const checkDist = 1.2;
        const checkX = Math.floor(gs.playerX + dirX * checkDist);
        const checkY = Math.floor(gs.playerY + dirY * checkDist);
        if (
          checkX >= 0 &&
          checkX < gs.mapWidth &&
          checkY >= 0 &&
          checkY < gs.mapHeight &&
          gs.map[checkY][checkX] === 5
        ) {
          // Open the door (remove wall)
          gs.map[checkY][checkX] = 0;
          gs.screenFlash = 'yellow';
          gs.flashTimer = 80;
        }
      }

      // ---- Pickup collection ----
      for (const pickup of gs.pickups) {
        if (pickup.collected) continue;
        if (dist(gs.playerX, gs.playerY, pickup.x, pickup.y) < PICKUP_RADIUS) {
          pickup.collected = true;
          gs.screenFlash = 'yellow';
          gs.flashTimer = 100;

          // Pickup particles
          let pickupColor = '#888888';

          if (pickup.type === 'health') {
            gs.playerHealth = Math.min(gs.playerHealth + pickup.value, 100);
            gs.message = 'PICKED UP HEALTH';
            gs.messageTimer = 2000;
            pickupColor = '#22cc22';
            gs.pickupFlashColor = '#22cc22';
            gs.pickupFlashTimer = 200;
          } else if (pickup.type === 'armor') {
            gs.playerArmor = Math.min(gs.playerArmor + pickup.value, 100);
            gs.message = 'PICKED UP ARMOR';
            gs.messageTimer = 2000;
            pickupColor = '#4488ff';
            gs.pickupFlashColor = '#4488ff';
            gs.pickupFlashTimer = 200;
          } else if (pickup.type.startsWith('ammo_')) {
            const ammoType = pickup.type.replace('ammo_', '');
            for (const w of gs.weapons) {
              if (w.ammoType === ammoType) {
                w.ammo = Math.min(w.ammo + pickup.value, w.maxAmmo);
              }
            }
            gs.message = `PICKED UP ${ammoType.toUpperCase()}`;
            gs.messageTimer = 2000;
            pickupColor = '#ddcc22';
            gs.pickupFlashColor = '#ddcc22';
            gs.pickupFlashTimer = 200;
          } else if (pickup.type.startsWith('weapon_')) {
            const wName = pickup.weaponName || '';
            const idx = gs.weapons.findIndex((w) => w.name === wName);
            if (idx >= 0) {
              gs.weapons[idx].owned = true;
              gs.currentWeapon = idx;
            }
            gs.message = `PICKED UP ${wName.toUpperCase()}`;
            gs.messageTimer = 2000;
            pickupColor = '#00cccc';
            gs.pickupFlashColor = '#00cccc';
            gs.pickupFlashTimer = 200;
          }

          // Spawn pickup particles
          spawnParticles(gs.particles, SCREEN_W / 2, SCREEN_H * 0.6, 6, pickupColor, 4, 400, 2);

          gs.score += 10;
        }
      }

      // ---- Secret areas ----
      for (const secret of gs.secrets) {
        if (secret.found) continue;
        if (dist(gs.playerX, gs.playerY, secret.x, secret.y) < PICKUP_RADIUS) {
          secret.found = true;
          gs.secretsFound++;
          gs.message = 'SECRET AREA FOUND!';
          gs.messageTimer = 3000;
          gs.score += 200;
        }
      }

      // ---- Level exit (single-player only) ----
      if (!gs.multiplayerMode) {
        if (dist(gs.playerX, gs.playerY, gs.exitX, gs.exitY) < EXIT_RADIUS) {
          gs.levelTransition = true;
          gs.levelTransitionTimer = 2000;
          gs.message = 'LEVEL COMPLETE!';
          gs.messageTimer = 2000;
        }
      }

      // ---- Enemy AI (single-player and multiplayer PvE) ----
      if (now - gs.lastEnemyAIUpdate > ENEMY_AI_INTERVAL) {
        gs.lastEnemyAIUpdate = now;
        const aiDt = ENEMY_AI_INTERVAL / 1000;

        for (const enemy of gs.enemies) {
          if (!enemy.alive) continue;

          const d = dist(gs.playerX, gs.playerY, enemy.x, enemy.y);
          const los =
            d < ENEMY_SIGHT_RANGE &&
            hasLineOfSight(
              enemy.x,
              enemy.y,
              gs.playerX,
              gs.playerY,
              gs.map,
              gs.mapWidth,
              gs.mapHeight,
            );
          const eDef = ENEMY_TYPES[enemy.type];
          if (!eDef) continue;

          switch (enemy.state) {
            case 'idle':
              if (los) {
                enemy.state = 'alert';
                enemy.alertTimer = 1000;
              }
              break;

            case 'alert':
              enemy.alertTimer -= ENEMY_AI_INTERVAL;
              if (los) {
                enemy.state = 'chasing';
                enemy.lostSightTimer = 0;
              } else if (enemy.alertTimer <= 0) {
                enemy.state = 'idle';
              }
              break;

            case 'chasing': {
              if (!los) {
                enemy.lostSightTimer += ENEMY_AI_INTERVAL;
                if (enemy.lostSightTimer > 3000) {
                  enemy.state = 'idle';
                  break;
                }
              } else {
                enemy.lostSightTimer = 0;
              }

              if (d <= eDef.attackRange) {
                enemy.state = 'attacking';
                break;
              }

              // Move toward player
              const dx = gs.playerX - enemy.x;
              const dy = gs.playerY - enemy.y;
              const len = Math.sqrt(dx * dx + dy * dy);
              if (len > 0.01) {
                const mx = (dx / len) * eDef.speed * aiDt;
                const my = (dy / len) * eDef.speed * aiDt;
                const nx = enemy.x + mx;
                const ny = enemy.y + my;
                const fmx = Math.floor(nx);
                const fmy = Math.floor(ny);
                if (fmx >= 0 && fmx < gs.mapWidth && fmy >= 0 && fmy < gs.mapHeight) {
                  if (gs.map[fmy][fmx] === 0) {
                    enemy.x = nx;
                    enemy.y = ny;
                  } else if (gs.map[Math.floor(enemy.y)][fmx] === 0) {
                    enemy.x = nx;
                  } else if (gs.map[fmy][Math.floor(enemy.x)] === 0) {
                    enemy.y = ny;
                  }
                }
              }
              break;
            }

            case 'attacking':
              if (d > eDef.attackRange * 1.5) {
                enemy.state = 'chasing';
                break;
              }
              if (now - enemy.lastAttack > eDef.attackRate) {
                enemy.lastAttack = now;

                // Check invincibility
                if (gs.invincibilityTimer > 0) {
                  // No damage taken
                  break;
                }

                // Deal damage to player
                let damage = eDef.damage;
                if (gs.playerArmor > 0) {
                  const armorAbsorb = Math.min(gs.playerArmor, Math.floor(damage * 0.6));
                  gs.playerArmor -= armorAbsorb;
                  damage -= armorAbsorb;
                }
                gs.playerHealth -= damage;
                gs.screenFlash = 'red';
                gs.flashTimer = 150;
                gs.damageVignetteTimer = 200;
                gs.shakeTimer = 150;
                gs.shakeIntensity = 3;

                // Damage direction particles
                spawnParticles(
                  gs.particles,
                  Math.random() * SCREEN_W,
                  Math.random() < 0.5 ? 0 : SCREEN_H,
                  4,
                  '#ff3333',
                  4,
                  300,
                  3,
                );

                if (gs.playerHealth <= 0) {
                  // Check extra lives
                  if (gs.extraLives > 0) {
                    gs.extraLives--;
                    gs.playerHealth = 50;
                    gs.screenFlash = 'yellow';
                    gs.flashTimer = 500;
                    gs.message = 'EXTRA LIFE USED!';
                    gs.messageTimer = 2000;
                    // Gold flash particles
                    spawnParticles(
                      gs.particles,
                      SCREEN_W / 2,
                      SCREEN_H / 2,
                      8,
                      '#FFD700',
                      6,
                      500,
                      3,
                    );
                  } else {
                    gs.playerHealth = 0;
                    gs.gameOver = true;
                  }
                }
              }
              break;
          }
        }
      }

      // ---- Multiplayer: Send position updates at 20Hz ----
      if (
        gs.multiplayerMode &&
        gs.matchStatus === 'playing' &&
        gs.wsRef &&
        gs.wsRef.readyState === WebSocket.OPEN
      ) {
        if (now - gs.lastNetworkUpdate > 50) {
          gs.wsRef.send(
            JSON.stringify({
              type: 'fps_update',
              payload: {
                x: gs.playerX,
                y: gs.playerY,
                angle: gs.playerAngle,
                health: gs.playerHealth,
                weaponIndex: gs.currentWeapon,
              },
            }),
          );
          gs.lastNetworkUpdate = now;
        }
      }

      // ---- Update particles and timers ----
      updateParticlesAndTimers(gs, dt);

      // ---- Render ----
      render(gs);
    },
    [started, initGame, shootWeapon],
  );

  // -----------------------------------------------------------------------
  // Consumable usage
  // -----------------------------------------------------------------------

  function useConsumable(gs: FPSGameState): void {
    for (let i = 0; i < gs.consumables.length; i++) {
      const c = gs.consumables[i];
      if (c.count <= 0) continue;

      if (c.type === 'damage_boost' && gs.damageBoostTimer <= 0) {
        c.count--;
        gs.damageBoostTimer = 30000; // 30 seconds
        gs.message = 'DAMAGE BOOST ACTIVE!';
        gs.messageTimer = 2000;
        gs.screenFlash = 'red';
        gs.flashTimer = 200;
        return;
      }
      if (c.type === 'invincibility' && gs.invincibilityTimer <= 0) {
        c.count--;
        gs.invincibilityTimer = 10000; // 10 seconds
        gs.message = 'INVINCIBILITY ACTIVE!';
        gs.messageTimer = 2000;
        gs.screenFlash = 'yellow';
        gs.flashTimer = 300;
        return;
      }
    }
  }

  // -----------------------------------------------------------------------
  // Update particles and timers
  // -----------------------------------------------------------------------

  function updateParticlesAndTimers(gs: FPSGameState, dt: number): void {
    // Update particles
    for (let i = gs.particles.length - 1; i >= 0; i--) {
      const p = gs.particles[i];
      p.x += p.vx;
      p.y += p.vy;
      p.vy += 0.1; // gravity
      p.life -= dt * 1000;
      if (p.life <= 0) {
        gs.particles.splice(i, 1);
      }
    }

    // Timers
    gs.gameTime += dt;
    if (gs.messageTimer > 0) {
      gs.messageTimer -= dt * 1000;
      if (gs.messageTimer <= 0) {
        gs.message = null;
        gs.messageTimer = 0;
      }
    }
    if (gs.flashTimer > 0) {
      gs.flashTimer -= dt * 1000;
      if (gs.flashTimer <= 0) {
        gs.screenFlash = null;
        gs.flashTimer = 0;
      }
    }
    if (gs.weaponRecoil > 0) {
      gs.weaponRecoil = Math.max(0, gs.weaponRecoil - dt * 60);
    }
    if (gs.shakeTimer > 0) {
      gs.shakeTimer -= dt * 1000;
    }
    if (gs.damageVignetteTimer > 0) {
      gs.damageVignetteTimer -= dt * 1000;
    }
    if (gs.pickupFlashTimer > 0) {
      gs.pickupFlashTimer -= dt * 1000;
      if (gs.pickupFlashTimer <= 0) {
        gs.pickupFlashColor = null;
      }
    }
    if (gs.damageBoostTimer > 0) {
      gs.damageBoostTimer -= dt * 1000;
    }
    if (gs.invincibilityTimer > 0) {
      gs.invincibilityTimer -= dt * 1000;
    }

    // Prune old kill feed entries
    const feedNow = Date.now();
    while (gs.killFeed.length > 0 && feedNow - gs.killFeed[0].time > KILL_FEED_DURATION) {
      gs.killFeed.shift();
    }
    while (gs.killFeed.length > KILL_FEED_MAX) {
      gs.killFeed.shift();
    }
  }

  // -----------------------------------------------------------------------
  // Rendering
  // -----------------------------------------------------------------------

  const render = useCallback((gs: FPSGameState) => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    const zBuffer = zBufferRef.current;

    // Screen shake offset
    let shakeX = 0;
    let shakeY = 0;
    if (gs.shakeTimer > 0) {
      shakeX = (Math.random() - 0.5) * gs.shakeIntensity * 2;
      shakeY = (Math.random() - 0.5) * gs.shakeIntensity * 2;
    }

    ctx.save();
    ctx.translate(shakeX, shakeY);

    // --- Clear ---
    ctx.fillStyle = '#000';
    ctx.fillRect(-5, -5, SCREEN_W + 10, SCREEN_H + 10);

    // --- Ceiling (dark atmospheric) ---
    const ceilGrad = ctx.createLinearGradient(0, 0, 0, SCREEN_H / 2);
    ceilGrad.addColorStop(0, '#020208');
    ceilGrad.addColorStop(0.4, '#060612');
    ceilGrad.addColorStop(0.8, '#0c0c18');
    ceilGrad.addColorStop(1, '#151520');
    ctx.fillStyle = ceilGrad;
    ctx.fillRect(0, 0, SCREEN_W, SCREEN_H / 2);

    // Star field (pre-computed positions, varying sizes and alpha)
    for (let si = 0; si < STAR_FIELD.length; si++) {
      const star = STAR_FIELD[si];
      ctx.fillStyle = `rgba(255, 255, 255, ${star.alpha})`;
      ctx.fillRect(star.x, star.y, star.size, star.size);
    }

    // --- Floor (depth illusion: lighter near horizon, dark at bottom) ---
    const floorGrad = ctx.createLinearGradient(0, SCREEN_H / 2, 0, SCREEN_H);
    floorGrad.addColorStop(0, '#3a3530');
    floorGrad.addColorStop(0.2, '#2a2520');
    floorGrad.addColorStop(0.5, '#1a1612');
    floorGrad.addColorStop(1, '#0a0908');
    ctx.fillStyle = floorGrad;
    ctx.fillRect(0, SCREEN_H / 2, SCREEN_W, SCREEN_H / 2);

    // Floor scan lines (subtle CRT feel)
    ctx.fillStyle = 'rgba(0, 0, 0, 0.04)';
    for (let scanY = SCREEN_H / 2; scanY < SCREEN_H; scanY += 3) {
      ctx.fillRect(0, scanY, SCREEN_W, 1);
    }

    // --- Raycasting ---
    const playerDirX = Math.cos(gs.playerAngle);
    const playerDirY = Math.sin(gs.playerAngle);
    const planeX = -playerDirY * Math.tan(HALF_FOV);
    const planeY = playerDirX * Math.tan(HALF_FOV);

    for (let x = 0; x < SCREEN_W; x++) {
      const cameraX = (2 * x) / SCREEN_W - 1;
      const rayDirX = playerDirX + planeX * cameraX;
      const rayDirY = playerDirY + planeY * cameraX;

      let mapX = Math.floor(gs.playerX);
      let mapY = Math.floor(gs.playerY);

      const deltaDistX = Math.abs(rayDirX) < 1e-10 ? 1e10 : Math.abs(1 / rayDirX);
      const deltaDistY = Math.abs(rayDirY) < 1e-10 ? 1e10 : Math.abs(1 / rayDirY);

      let stepX: number;
      let sideDistX: number;
      if (rayDirX < 0) {
        stepX = -1;
        sideDistX = (gs.playerX - mapX) * deltaDistX;
      } else {
        stepX = 1;
        sideDistX = (mapX + 1 - gs.playerX) * deltaDistX;
      }

      let stepY: number;
      let sideDistY: number;
      if (rayDirY < 0) {
        stepY = -1;
        sideDistY = (gs.playerY - mapY) * deltaDistY;
      } else {
        stepY = 1;
        sideDistY = (mapY + 1 - gs.playerY) * deltaDistY;
      }

      let side = 0;
      let hit = false;

      // DDA loop
      for (let step = 0; step < 64; step++) {
        if (sideDistX < sideDistY) {
          sideDistX += deltaDistX;
          mapX += stepX;
          side = 0;
        } else {
          sideDistY += deltaDistY;
          mapY += stepY;
          side = 1;
        }

        if (mapX < 0 || mapX >= gs.mapWidth || mapY < 0 || mapY >= gs.mapHeight) break;
        if (gs.map[mapY][mapX] > 0) {
          hit = true;
          break;
        }
      }

      if (!hit) {
        zBuffer[x] = 1e10;
        continue;
      }

      // Perpendicular distance (prevents fisheye)
      let perpDist: number;
      if (side === 0) {
        perpDist = (mapX - gs.playerX + (1 - stepX) / 2) / rayDirX;
      } else {
        perpDist = (mapY - gs.playerY + (1 - stepY) / 2) / rayDirY;
      }

      if (perpDist <= 0) perpDist = 0.01;
      zBuffer[x] = perpDist;

      // Wall strip
      const lineHeight = SCREEN_H / perpDist;
      const drawStart = Math.max(0, Math.floor(SCREEN_H / 2 - lineHeight / 2));
      const drawEnd = Math.min(SCREEN_H, Math.floor(SCREEN_H / 2 + lineHeight / 2));

      // Texture-mapped wall rendering
      const wallType = gs.map[mapY][mapX];
      const texIndex = clamp(wallType - 1, 0, WALL_TEXTURES.length - 1);
      const texture = WALL_TEXTURES[texIndex];

      // Compute texture X coordinate from wall hit position
      let wallHitX: number;
      if (side === 0) {
        wallHitX = gs.playerY + perpDist * rayDirY;
      } else {
        wallHitX = gs.playerX + perpDist * rayDirX;
      }
      wallHitX -= Math.floor(wallHitX);
      // Flip texture for certain sides to avoid mirroring
      if (side === 0 && rayDirX > 0) wallHitX = 1 - wallHitX;
      if (side === 1 && rayDirY < 0) wallHitX = 1 - wallHitX;

      const texX = Math.floor(wallHitX * TEX_SIZE) & (TEX_SIZE - 1);

      // Side shading factor (N/S vs E/W)
      const sideFactor = side === 1 ? 0.7 : 1.0;

      // Distance fog
      const fogFactor = clamp(1 - perpDist / 16, 0.15, 1);
      const combinedFactor = fogFactor * sideFactor;

      const stripHeight = drawEnd - drawStart;

      // For distant walls (small strips), draw base color only
      if (stripHeight < 12 || perpDist > 10) {
        const baseColor = WALL_COLORS[wallType] || [100, 95, 90];
        const br = Math.floor(baseColor[0] * combinedFactor);
        const bg = Math.floor(baseColor[1] * combinedFactor);
        const bb = Math.floor(baseColor[2] * combinedFactor);
        ctx.fillStyle = `rgb(${br},${bg},${bb})`;
        ctx.fillRect(x, drawStart, 1, stripHeight);
      } else {
        // Sample texture for nearby walls (visible detail)
        // Use step-based sampling: step through texture Y in chunks for performance
        const fullLineHeight = SCREEN_H / perpDist;
        const texStepY = TEX_SIZE / fullLineHeight;
        let texYStart = (drawStart - (SCREEN_H / 2 - fullLineHeight / 2)) * texStepY;

        // Draw in chunks of 2 pixels for performance
        const chunkSize = 2;
        for (let py = drawStart; py < drawEnd; py += chunkSize) {
          const texY = Math.floor(texYStart) & (TEX_SIZE - 1);
          const texIdx = (texY * TEX_SIZE + texX) * 3;
          const tr = texture[texIdx];
          const tg = texture[texIdx + 1];
          const tb = texture[texIdx + 2];
          const fr = Math.floor(tr * combinedFactor);
          const fg = Math.floor(tg * combinedFactor);
          const fb = Math.floor(tb * combinedFactor);
          ctx.fillStyle = `rgb(${fr},${fg},${fb})`;
          const h = Math.min(chunkSize, drawEnd - py);
          ctx.fillRect(x, py, 1, h);
          texYStart += texStepY * chunkSize;
        }
      }

      // Edge definition: thin dark line at top and bottom
      ctx.fillStyle = 'rgba(0, 0, 0, 0.35)';
      ctx.fillRect(x, drawStart, 1, 1);
      ctx.fillRect(x, drawEnd - 1, 1, 1);
    }

    // --- Sprites (enemies, pickups, and remote players) ---
    drawSprites(ctx, gs, zBuffer, playerDirX, playerDirY, planeX, planeY);

    // --- Particles ---
    drawParticles(ctx, gs);

    // --- Weapon / Hand view ---
    drawWeaponView(ctx, gs);

    // --- Vignette post-processing (frames the view) ---
    const vigGrad = ctx.createRadialGradient(
      SCREEN_W / 2,
      SCREEN_H / 2,
      SCREEN_H * 0.35,
      SCREEN_W / 2,
      SCREEN_H / 2,
      SCREEN_H * 0.85,
    );
    vigGrad.addColorStop(0, 'rgba(0, 0, 0, 0)');
    vigGrad.addColorStop(0.6, 'rgba(0, 0, 0, 0.1)');
    vigGrad.addColorStop(1, 'rgba(0, 0, 0, 0.45)');
    ctx.fillStyle = vigGrad;
    ctx.fillRect(0, 0, SCREEN_W, SCREEN_H);

    // --- HUD ---
    drawHUD(ctx, gs);

    // --- Kill feed ---
    drawKillFeed(ctx, gs);

    // --- Messages ---
    if (gs.message) {
      const alpha = gs.messageTimer > 500 ? 1 : gs.messageTimer / 500;
      ctx.save();
      ctx.globalAlpha = alpha;
      ctx.font = 'bold 28px monospace';
      ctx.fillStyle = '#FFD700';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(gs.message, SCREEN_W / 2, SCREEN_H / 3);
      ctx.restore();
    }

    // --- Damage vignette (red edges) ---
    if (gs.damageVignetteTimer > 0) {
      const vigAlpha = (gs.damageVignetteTimer / 200) * 0.5;
      // Top edge
      const topGrad = ctx.createLinearGradient(0, 0, 0, 80);
      topGrad.addColorStop(0, `rgba(255, 0, 0, ${vigAlpha})`);
      topGrad.addColorStop(1, 'rgba(255, 0, 0, 0)');
      ctx.fillStyle = topGrad;
      ctx.fillRect(0, 0, SCREEN_W, 80);
      // Bottom edge
      const bottomGrad = ctx.createLinearGradient(0, SCREEN_H - 80, 0, SCREEN_H);
      bottomGrad.addColorStop(0, 'rgba(255, 0, 0, 0)');
      bottomGrad.addColorStop(1, `rgba(255, 0, 0, ${vigAlpha})`);
      ctx.fillStyle = bottomGrad;
      ctx.fillRect(0, SCREEN_H - 80, SCREEN_W, 80);
      // Left edge
      const leftGrad = ctx.createLinearGradient(0, 0, 60, 0);
      leftGrad.addColorStop(0, `rgba(255, 0, 0, ${vigAlpha})`);
      leftGrad.addColorStop(1, 'rgba(255, 0, 0, 0)');
      ctx.fillStyle = leftGrad;
      ctx.fillRect(0, 0, 60, SCREEN_H);
      // Right edge
      const rightGrad = ctx.createLinearGradient(SCREEN_W - 60, 0, SCREEN_W, 0);
      rightGrad.addColorStop(0, 'rgba(255, 0, 0, 0)');
      rightGrad.addColorStop(1, `rgba(255, 0, 0, ${vigAlpha})`);
      ctx.fillStyle = rightGrad;
      ctx.fillRect(SCREEN_W - 60, 0, 60, SCREEN_H);
    }

    // --- Low health warning (pulsing red edges) ---
    if (gs.playerHealth > 0 && gs.playerHealth < 25 && gs.damageVignetteTimer <= 0) {
      const pulse = (Math.sin(Date.now() / 300) * 0.5 + 0.5) * 0.25;
      const lowGrad = ctx.createRadialGradient(
        SCREEN_W / 2,
        SCREEN_H / 2,
        SCREEN_H * 0.3,
        SCREEN_W / 2,
        SCREEN_H / 2,
        SCREEN_H * 0.8,
      );
      lowGrad.addColorStop(0, 'rgba(255, 0, 0, 0)');
      lowGrad.addColorStop(1, `rgba(255, 0, 0, ${pulse})`);
      ctx.fillStyle = lowGrad;
      ctx.fillRect(0, 0, SCREEN_W, SCREEN_H);
    }

    // --- Pickup flash (bottom of screen) ---
    if (gs.pickupFlashColor && gs.pickupFlashTimer > 0) {
      const pfAlpha = (gs.pickupFlashTimer / 200) * 0.3;
      ctx.save();
      ctx.globalAlpha = pfAlpha;
      const pfGrad = ctx.createLinearGradient(0, SCREEN_H - 100, 0, SCREEN_H);
      pfGrad.addColorStop(0, 'rgba(0, 0, 0, 0)');
      pfGrad.addColorStop(1, gs.pickupFlashColor);
      ctx.fillStyle = pfGrad;
      ctx.fillRect(0, SCREEN_H - 100, SCREEN_W, 100);
      ctx.restore();
    }

    // --- Screen flash ---
    if (gs.screenFlash) {
      ctx.save();
      ctx.globalAlpha = 0.2;
      ctx.fillStyle = gs.screenFlash === 'red' ? '#FF0000' : '#FFFF00';
      ctx.fillRect(0, 0, SCREEN_W, SCREEN_H);
      ctx.restore();
    }

    // --- Invincibility pulse effect ---
    if (gs.invincibilityTimer > 0) {
      const invPulse = (Math.sin(Date.now() / 100) * 0.5 + 0.5) * 0.15;
      ctx.save();
      ctx.globalAlpha = invPulse;
      ctx.fillStyle = '#ffff88';
      ctx.fillRect(0, 0, SCREEN_W, SCREEN_H);
      ctx.restore();
    }

    // --- Consumable timers on HUD ---
    drawConsumableTimers(ctx, gs);

    // --- Multiplayer overlays ---
    if (gs.multiplayerMode) {
      drawMultiplayerOverlay(ctx, gs);
    }

    // --- Game over ---
    if (gs.gameOver) {
      drawGameOverScreen(ctx, gs);
    }

    // --- Victory ---
    if (gs.victory) {
      drawVictoryScreen(ctx, gs);
    }

    // --- Level transition ---
    if (gs.levelTransition) {
      const alpha = clamp(1 - gs.levelTransitionTimer / 2000, 0, 1);
      ctx.save();
      ctx.globalAlpha = alpha * 0.8;
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, SCREEN_W, SCREEN_H);
      ctx.restore();
    }

    ctx.restore(); // End shake transform
  }, []);

  // -----------------------------------------------------------------------
  // Draw particles
  // -----------------------------------------------------------------------

  const drawParticles = useCallback((ctx: CanvasRenderingContext2D, gs: FPSGameState) => {
    for (const p of gs.particles) {
      const alpha = clamp(p.life / p.maxLife, 0, 1);
      ctx.save();
      ctx.globalAlpha = alpha;
      ctx.fillStyle = p.color;
      ctx.fillRect(Math.floor(p.x), Math.floor(p.y), p.size, p.size);
      ctx.restore();
    }
  }, []);

  // -----------------------------------------------------------------------
  // Draw kill feed
  // -----------------------------------------------------------------------

  const drawKillFeed = useCallback((ctx: CanvasRenderingContext2D, gs: FPSGameState) => {
    if (gs.killFeed.length === 0) return;
    const feedX = SCREEN_W - 140;
    const feedStartY = 160; // Below minimap
    const now = Date.now();

    ctx.save();
    ctx.textAlign = 'right';
    ctx.font = '11px monospace';

    for (let i = 0; i < gs.killFeed.length; i++) {
      const entry = gs.killFeed[i];
      const age = now - entry.time;
      const alpha = age > KILL_FEED_DURATION - 1000 ? (KILL_FEED_DURATION - age) / 1000 : 1;
      ctx.globalAlpha = clamp(alpha, 0, 1);
      ctx.fillStyle = entry.color;
      ctx.fillText(entry.text, feedX, feedStartY + i * 14);
    }

    ctx.restore();
  }, []);

  // -----------------------------------------------------------------------
  // Draw consumable timers
  // -----------------------------------------------------------------------

  const drawConsumableTimers = useCallback((ctx: CanvasRenderingContext2D, gs: FPSGameState) => {
    let timerY = SCREEN_H - 80;

    ctx.save();
    ctx.textAlign = 'left';
    ctx.font = 'bold 12px monospace';

    if (gs.damageBoostTimer > 0) {
      const secs = Math.ceil(gs.damageBoostTimer / 1000);
      ctx.fillStyle = '#ff4444';
      ctx.fillText(`DMG BOOST: ${secs}s`, 10, timerY);
      timerY -= 16;
    }

    if (gs.invincibilityTimer > 0) {
      const secs = Math.ceil(gs.invincibilityTimer / 1000);
      ctx.fillStyle = '#ffff44';
      ctx.fillText(`INVINCIBLE: ${secs}s`, 10, timerY);
      timerY -= 16;
    }

    // Show consumable inventory (bottom left)
    if (gs.consumables.length > 0 || gs.extraLives > 0) {
      ctx.font = '11px monospace';
      let invY = SCREEN_H - 15;
      ctx.fillStyle = '#aaa';
      ctx.fillText('[Q] Use Consumable', 180, invY);
      invY -= 14;
      if (gs.extraLives > 0) {
        ctx.fillStyle = '#FFD700';
        ctx.fillText(`Extra Lives: ${gs.extraLives}`, 180, invY);
        invY -= 14;
      }
      for (const c of gs.consumables) {
        if (c.count <= 0) continue;
        const label =
          c.type === 'damage_boost'
            ? 'Dmg Boost'
            : c.type === 'invincibility'
              ? 'Invincible'
              : c.type;
        ctx.fillStyle = c.type === 'damage_boost' ? '#ff6666' : '#ffff66';
        ctx.fillText(`${label}: ${c.count}`, 180, invY);
        invY -= 14;
      }
    }

    ctx.restore();
  }, []);

  // -----------------------------------------------------------------------
  // Draw sprites
  // -----------------------------------------------------------------------

  const drawSprites = useCallback(
    (
      ctx: CanvasRenderingContext2D,
      gs: FPSGameState,
      zBuffer: Float64Array,
      dirX: number,
      dirY: number,
      planeX: number,
      planeY: number,
    ) => {
      // Collect all sprites
      type SpriteItem = {
        x: number;
        y: number;
        type: 'enemy' | 'pickup' | 'remote_player';
        data: EnemyState | PickupState | RemotePlayer;
      };
      const sprites: SpriteItem[] = [];

      for (const enemy of gs.enemies) {
        if (!enemy.alive) continue;
        sprites.push({ x: enemy.x, y: enemy.y, type: 'enemy', data: enemy });
      }
      for (const pickup of gs.pickups) {
        if (pickup.collected) continue;
        sprites.push({ x: pickup.x, y: pickup.y, type: 'pickup', data: pickup });
      }

      // Remote players in multiplayer
      if (gs.multiplayerMode) {
        const now = Date.now();
        gs.remotePlayers.forEach((remote) => {
          if (!remote.alive) return;
          // Interpolate position
          const t = clamp((now - remote.lastUpdate) / 50, 0, 1);
          const renderX = remote.prevX + (remote.x - remote.prevX) * t;
          const renderY = remote.prevY + (remote.y - remote.prevY) * t;
          sprites.push({ x: renderX, y: renderY, type: 'remote_player', data: remote });
        });
      }

      // Sort back to front
      sprites.sort((a, b) => {
        const da =
          (a.x - gs.playerX) * (a.x - gs.playerX) + (a.y - gs.playerY) * (a.y - gs.playerY);
        const db =
          (b.x - gs.playerX) * (b.x - gs.playerX) + (b.y - gs.playerY) * (b.y - gs.playerY);
        return db - da;
      });

      const invDet = 1 / (planeX * dirY - dirX * planeY);

      for (const sprite of sprites) {
        const sx = sprite.x - gs.playerX;
        const sy = sprite.y - gs.playerY;

        const transformX = invDet * (dirY * sx - dirX * sy);
        const transformY = invDet * (-planeY * sx + planeX * sy);

        if (transformY <= 0.1) continue; // behind camera

        const spriteScreenX = Math.floor((SCREEN_W / 2) * (1 + transformX / transformY));

        let spriteScaleW = 1;
        let spriteScaleH = 1;

        if (sprite.type === 'enemy') {
          const eDef = ENEMY_TYPES[(sprite.data as EnemyState).type];
          if (eDef) {
            spriteScaleW = eDef.width;
            spriteScaleH = eDef.height;
          }
        } else if (sprite.type === 'pickup') {
          spriteScaleW = 0.5;
          spriteScaleH = 0.5;
        } else {
          // remote_player
          spriteScaleW = 1;
          spriteScaleH = 1;
        }

        const spriteHeight = Math.abs(Math.floor(SCREEN_H / transformY)) * spriteScaleH;
        const spriteWidth = Math.abs(Math.floor(SCREEN_H / transformY)) * spriteScaleW;

        const drawStartY = Math.floor(SCREEN_H / 2 - spriteHeight / 2);
        const drawEndY = Math.floor(SCREEN_H / 2 + spriteHeight / 2);
        const drawStartX = Math.floor(spriteScreenX - spriteWidth / 2);
        const drawEndX = Math.floor(spriteScreenX + spriteWidth / 2);

        // Clip and draw
        const startX = Math.max(drawStartX, 0);
        const endX = Math.min(drawEndX, SCREEN_W);

        // Check if any column is visible
        let visible = false;
        for (let stripe = startX; stripe < endX; stripe++) {
          if (transformY < zBuffer[stripe]) {
            visible = true;
            break;
          }
        }
        if (!visible) continue;

        // Distance fog
        const fogFactor = clamp(1 - transformY / 16, 0.2, 1);

        if (sprite.type === 'enemy') {
          drawEnemySprite(
            ctx,
            gs,
            sprite.data as EnemyState,
            fogFactor,
            zBuffer,
            transformY,
            spriteScreenX,
            drawStartX,
            drawEndX,
            drawStartY,
            drawEndY,
            startX,
            endX,
            spriteWidth,
            spriteHeight,
          );
        } else if (sprite.type === 'remote_player') {
          drawRemotePlayerSprite(
            ctx,
            gs,
            sprite.data as RemotePlayer,
            fogFactor,
            zBuffer,
            transformY,
            spriteScreenX,
            drawStartX,
            drawEndX,
            drawStartY,
            drawEndY,
            startX,
            endX,
            spriteWidth,
            spriteHeight,
          );
        } else {
          // Pickup sprite
          const pickup = sprite.data as PickupState;

          // Floating bob
          const bob = Math.sin(Date.now() / 300 + pickup.id) * spriteHeight * 0.05;
          const cy = SCREEN_H / 2 + bob;
          const csy = Math.floor(cy - spriteHeight / 2);
          const cey = Math.floor(cy + spriteHeight / 2);

          for (let stripe = startX; stripe < endX; stripe++) {
            if (transformY >= zBuffer[stripe]) continue;

            let color = '#888';
            if (pickup.type === 'health') color = '#22cc22';
            else if (pickup.type === 'armor') color = '#4488ff';
            else if (pickup.type.startsWith('ammo_')) color = '#ddcc22';
            else if (pickup.type.startsWith('weapon_')) color = '#00cccc';

            ctx.fillStyle = color;
            ctx.globalAlpha = fogFactor;
            ctx.fillRect(stripe, csy, 1, cey - csy);
            ctx.globalAlpha = 1;
          }
        }
      }
    },
    [],
  );

  // -----------------------------------------------------------------------
  // Draw detailed enemy sprite
  // -----------------------------------------------------------------------

  function drawEnemySprite(
    ctx: CanvasRenderingContext2D,
    _gs: FPSGameState,
    enemy: EnemyState,
    fogFactor: number,
    zBuffer: Float64Array,
    transformY: number,
    spriteScreenX: number,
    drawStartX: number,
    _drawEndX: number,
    drawStartY: number,
    _drawEndY: number,
    startX: number,
    endX: number,
    spriteWidth: number,
    spriteHeight: number,
  ): void {
    if (!ENEMY_TYPES[enemy.type]) return;

    // Get pixel art sprite and palette for this enemy type
    const spriteData = ENEMY_SPRITES[enemy.type];
    const palette = ENEMY_PALETTES[enemy.type];
    if (!spriteData || !palette) return;

    // Compute pixel size: scale sprite to fill the sprite bounds
    const spritePixelRows = spriteData.length;
    const spritePixelCols = spriteData[0].length;
    const pixelSizeX = spriteWidth / spritePixelCols;
    const pixelSizeY = spriteHeight / spritePixelRows;
    const pixelSize = Math.max(1, Math.floor(Math.min(pixelSizeX, pixelSizeY)));

    // Center the sprite in the draw area
    const totalDrawW = spritePixelCols * pixelSize;
    const totalDrawH = spritePixelRows * pixelSize;
    const offsetX = drawStartX + Math.floor((spriteWidth - totalDrawW) / 2);
    const offsetY = drawStartY + Math.floor((spriteHeight - totalDrawH) / 2);

    // Draw each pixel of the sprite, checking zBuffer per column
    for (let row = 0; row < spritePixelRows; row++) {
      const rowData = spriteData[row];
      const py = Math.floor(offsetY + row * pixelSize);
      if (py + pixelSize < 0 || py >= SCREEN_H) continue;
      for (let col = 0; col < spritePixelCols; col++) {
        const palIdx = rowData[col];
        if (palIdx === 0) continue; // transparent
        const px = Math.floor(offsetX + col * pixelSize);
        if (px + pixelSize < startX || px >= endX) continue;
        // Check zBuffer for the center of this pixel
        const centerX = Math.floor(px + pixelSize / 2);
        if (centerX >= 0 && centerX < SCREEN_W && transformY >= zBuffer[centerX]) continue;

        const color = palette[palIdx];
        if (!color) continue;
        const cr = Math.floor(color[0] * fogFactor);
        const cg = Math.floor(color[1] * fogFactor);
        const cb = Math.floor(color[2] * fogFactor);
        ctx.fillStyle = `rgb(${cr},${cg},${cb})`;
        const drawW = Math.min(pixelSize, SCREEN_W - px);
        const drawH = Math.min(pixelSize, SCREEN_H - py);
        if (drawW > 0 && drawH > 0) {
          ctx.fillRect(px, Math.max(0, py), drawW, drawH);
        }
      }
    }

    // Boss: add glowing eyes effect on top of the sprite
    if (enemy.type === 'boss' && spriteHeight > 20) {
      const eyeRow = 5; // row in sprite where eyes are
      const eyeCol1 = 5; // left eye column
      const eyeCol2 = 13; // right eye column
      const eyeX1 = Math.floor(offsetX + eyeCol1 * pixelSize);
      const eyeY1 = Math.floor(offsetY + eyeRow * pixelSize);
      const eyeX2 = Math.floor(offsetX + eyeCol2 * pixelSize);
      const eyeSize = Math.max(2, pixelSize);
      ctx.fillStyle = '#ff2222';
      ctx.shadowColor = '#ff0000';
      ctx.shadowBlur = Math.min(8, pixelSize * 2);
      ctx.fillRect(eyeX1, eyeY1, eyeSize, eyeSize);
      ctx.fillRect(eyeX2, eyeY1, eyeSize, eyeSize);
      ctx.shadowBlur = 0;
    }

    // Health bar for damaged enemies
    if (enemy.health < enemy.maxHealth && enemy.health > 0) {
      const barW = Math.min(endX - startX, 40);
      const barX = spriteScreenX - barW / 2;
      const headTop = Math.max(drawStartY, 0);
      const barY = Math.max(headTop - 8, 0);
      const hpPct = enemy.health / enemy.maxHealth;
      ctx.fillStyle = '#333';
      ctx.fillRect(barX, barY, barW, 4);
      ctx.fillStyle = hpPct > 0.5 ? '#0f0' : hpPct > 0.25 ? '#ff0' : '#f00';
      ctx.fillRect(barX, barY, barW * hpPct, 4);
    }
  }

  // -----------------------------------------------------------------------
  // Draw remote player sprite (multiplayer)
  // -----------------------------------------------------------------------

  function drawRemotePlayerSprite(
    ctx: CanvasRenderingContext2D,
    gs: FPSGameState,
    remote: RemotePlayer,
    fogFactor: number,
    zBuffer: Float64Array,
    transformY: number,
    spriteScreenX: number,
    drawStartX: number,
    _drawEndX: number,
    drawStartY: number,
    drawEndY: number,
    startX: number,
    endX: number,
    spriteWidth: number,
    spriteHeight: number,
  ): void {
    // Determine player color based on their index
    const playerIds = Array.from(gs.remotePlayers.keys());
    const colorIndex = playerIds.indexOf(remote.id) % MP_PLAYER_COLORS.length;
    const playerColor = MP_PLAYER_COLORS[colorIndex];

    // Parse hex color to RGB
    const hexToRgb = (hex: string) => {
      const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
      return result
        ? {
            r: parseInt(result[1], 16),
            g: parseInt(result[2], 16),
            b: parseInt(result[3], 16),
          }
        : { r: 128, g: 128, b: 128 };
    };

    const pc = hexToRgb(playerColor);
    const r = Math.floor(pc.r * fogFactor);
    const g = Math.floor(pc.g * fogFactor);
    const b = Math.floor(pc.b * fogFactor);

    const headTop = Math.max(drawStartY, 0);
    const headBottom = Math.max(drawStartY + Math.floor(spriteHeight * 0.2), 0);
    const bodyTop = headBottom;
    const bodyBottom = Math.min(drawEndY, SCREEN_H);
    const headLeft = drawStartX + Math.floor(spriteWidth * 0.3);
    const headRight = drawStartX + Math.floor(spriteWidth * 0.7);
    const bodyLeft = drawStartX + Math.floor(spriteWidth * 0.15);
    const bodyRight = drawStartX + Math.floor(spriteWidth * 0.85);

    for (let stripe = startX; stripe < endX; stripe++) {
      if (transformY >= zBuffer[stripe]) continue;
      // Head
      if (stripe >= headLeft && stripe < headRight && headTop < headBottom) {
        ctx.fillStyle = `rgb(${Math.min(255, Math.floor(r * 1.3))},${Math.min(255, Math.floor(g * 1.3))},${Math.min(255, Math.floor(b * 1.3))})`;
        ctx.fillRect(stripe, headTop, 1, headBottom - headTop);
      }
      // Body
      if (stripe >= bodyLeft && stripe < bodyRight) {
        ctx.fillStyle = `rgb(${r},${g},${b})`;
        ctx.fillRect(stripe, bodyTop, 1, bodyBottom - bodyTop);
      }
    }

    // Player name above head
    ctx.save();
    ctx.font = '10px monospace';
    ctx.textAlign = 'center';
    ctx.fillStyle = playerColor;
    ctx.globalAlpha = fogFactor;
    ctx.fillText(remote.name, spriteScreenX, Math.max(headTop - 18, 8));

    // Health bar
    if (remote.health < 100 && remote.health > 0) {
      const barW = Math.min(endX - startX, 40);
      const barX = spriteScreenX - barW / 2;
      const barY = Math.max(headTop - 12, 0);
      const hpPct = remote.health / 100;
      ctx.globalAlpha = fogFactor;
      ctx.fillStyle = '#333';
      ctx.fillRect(barX, barY, barW, 3);
      ctx.fillStyle = hpPct > 0.5 ? '#0f0' : hpPct > 0.25 ? '#ff0' : '#f00';
      ctx.fillRect(barX, barY, barW * hpPct, 3);
    }
    ctx.restore();
  }

  // -----------------------------------------------------------------------
  // Draw weapon / hand view (enhanced detail)
  // -----------------------------------------------------------------------

  const drawWeaponView = useCallback((ctx: CanvasRenderingContext2D, gs: FPSGameState) => {
    // Figure-8 weapon bob for walking, with recoil kick
    const bobX = Math.sin(gs.weaponBob) * 6;
    const bobY = Math.sin(gs.weaponBob * 2) * 3 + Math.abs(Math.sin(gs.weaponBob)) * 2;
    const recoilY = -gs.weaponRecoil * 1.5;
    const recoilTilt = gs.weaponRecoil * 0.3;

    const spriteData = WEAPON_SPRITES[gs.currentWeapon];
    if (!spriteData) return;

    const pixelSize = 4;
    const spriteW = spriteData[0].length * pixelSize;
    const spriteH = spriteData.length * pixelSize;

    const baseX = SCREEN_W / 2 - spriteW / 2 + bobX;
    const baseY = SCREEN_H - spriteH - 10 + bobY + recoilY + recoilTilt;

    // Build glove color override map for skin palette indices (7-10)
    let gloveOverride: Record<number, [number, number, number]> | undefined;
    if (gs.gloveColor !== 'default') {
      const gloveHex = GLOVE_COLORS[gs.gloveColor] || GLOVE_COLORS.default;
      // Parse hex to RGB
      const hr = parseInt(gloveHex.slice(1, 3), 16);
      const hg = parseInt(gloveHex.slice(3, 5), 16);
      const hb = parseInt(gloveHex.slice(5, 7), 16);
      gloveOverride = {
        7: [Math.floor(hr * 0.5), Math.floor(hg * 0.5), Math.floor(hb * 0.5)],
        8: [Math.floor(hr * 0.7), Math.floor(hg * 0.7), Math.floor(hb * 0.7)],
        9: [hr, hg, hb],
        10: [
          Math.min(255, Math.floor(hr * 1.2)),
          Math.min(255, Math.floor(hg * 1.2)),
          Math.min(255, Math.floor(hb * 1.2)),
        ],
      };
    }

    // Damage boost glow on weapon
    if (gs.damageBoostTimer > 0) {
      ctx.save();
      ctx.globalAlpha = 0.15 + Math.sin(Date.now() / 200) * 0.1;
      ctx.fillStyle = '#ff4444';
      ctx.beginPath();
      ctx.ellipse(
        baseX + spriteW / 2,
        baseY + spriteH * 0.6,
        spriteW * 0.6,
        spriteH * 0.4,
        0,
        0,
        Math.PI * 2,
      );
      ctx.fill();
      ctx.restore();
    }

    // Glove special effects (drawn behind the sprite)
    if (gs.gloveColor === 'cyber') {
      ctx.save();
      ctx.strokeStyle = '#00FFFF';
      ctx.lineWidth = 1;
      ctx.shadowColor = '#00FFFF';
      ctx.shadowBlur = 8;
      ctx.strokeRect(baseX + spriteW * 0.15, baseY + spriteH * 0.55, spriteW * 0.7, spriteH * 0.35);
      ctx.shadowBlur = 0;
      ctx.restore();
    } else if (gs.gloveColor === 'flame') {
      ctx.save();
      const flicker = Math.random() * 0.3 + 0.7;
      ctx.globalAlpha = flicker * 0.35;
      ctx.fillStyle = '#FF4500';
      ctx.beginPath();
      ctx.ellipse(
        baseX + spriteW / 2,
        baseY + spriteH * 0.7,
        spriteW * 0.5,
        spriteH * 0.3,
        0,
        0,
        Math.PI * 2,
      );
      ctx.fill();
      ctx.restore();
    }

    // Draw the pixel art weapon sprite
    drawPixelSprite(ctx, spriteData, WEAPON_PALETTE, baseX, baseY, pixelSize, 1, gloveOverride);

    // BFG: add glowing green orb on top of sprite
    if (gs.currentWeapon === 5) {
      const orbX = baseX + spriteW / 2;
      const orbY = baseY + spriteH * 0.1;
      const orbR = pixelSize * 4;
      const glowGrad = ctx.createRadialGradient(orbX, orbY, 2, orbX, orbY, orbR);
      glowGrad.addColorStop(0, '#00ff00');
      glowGrad.addColorStop(0.4, '#00cc00');
      glowGrad.addColorStop(0.8, '#00aa00');
      glowGrad.addColorStop(1, 'rgba(0, 170, 0, 0)');
      ctx.fillStyle = glowGrad;
      ctx.beginPath();
      ctx.arc(orbX, orbY, orbR, 0, Math.PI * 2);
      ctx.fill();
      // Energy arcs
      ctx.strokeStyle = '#88ff88';
      ctx.lineWidth = 1;
      for (let ai = 0; ai < 4; ai++) {
        const aAngle = Math.random() * Math.PI * 2;
        const aLen = orbR * 0.6 + Math.random() * orbR * 0.8;
        ctx.beginPath();
        ctx.moveTo(orbX + Math.cos(aAngle) * orbR * 0.5, orbY + Math.sin(aAngle) * orbR * 0.5);
        ctx.lineTo(orbX + Math.cos(aAngle) * aLen, orbY + Math.sin(aAngle) * aLen);
        ctx.stroke();
      }
      ctx.shadowColor = '#00ff00';
      ctx.shadowBlur = 12;
      ctx.fillStyle = '#00ff00';
      ctx.beginPath();
      ctx.arc(orbX, orbY, 4, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;
    }

    // Skeleton glove overlay (draw bone structure on top)
    if (gs.gloveColor === 'skeleton') {
      ctx.fillStyle = '#000';
      ctx.beginPath();
      ctx.ellipse(
        baseX + spriteW / 2,
        baseY + spriteH * 0.75,
        spriteW * 0.35,
        spriteH * 0.15,
        0,
        0,
        Math.PI * 2,
      );
      ctx.fill();
      ctx.fillStyle = '#FFF';
      for (let i = 0; i < 4; i++) {
        const fx = baseX + spriteW * 0.2 + i * (spriteW * 0.16);
        ctx.fillRect(fx, baseY + spriteH * 0.6, pixelSize * 1.5, spriteH * 0.2);
      }
    }

    // Enhanced muzzle flash
    if (gs.screenFlash === 'yellow' && gs.flashTimer > 0) {
      const flashX = baseX + spriteW / 2;
      const flashY = baseY - pixelSize * 2;

      // Screen brightness boost during flash
      ctx.save();
      ctx.globalAlpha = 0.08;
      ctx.fillStyle = '#FFFFCC';
      ctx.fillRect(0, 0, SCREEN_W, SCREEN_H);
      ctx.restore();

      // White-hot center
      const whiteGrad = ctx.createRadialGradient(flashX, flashY, 1, flashX, flashY, 15);
      whiteGrad.addColorStop(0, 'rgba(255, 255, 255, 0.95)');
      whiteGrad.addColorStop(0.5, 'rgba(255, 255, 200, 0.6)');
      whiteGrad.addColorStop(1, 'rgba(255, 255, 255, 0)');
      ctx.fillStyle = whiteGrad;
      ctx.beginPath();
      ctx.arc(flashX, flashY, 15, 0, Math.PI * 2);
      ctx.fill();

      // Orange-yellow middle ring
      const midGrad = ctx.createRadialGradient(flashX, flashY, 8, flashX, flashY, 30);
      midGrad.addColorStop(0, 'rgba(255, 200, 50, 0.7)');
      midGrad.addColorStop(0.6, 'rgba(255, 150, 0, 0.3)');
      midGrad.addColorStop(1, 'rgba(255, 200, 0, 0)');
      ctx.fillStyle = midGrad;
      ctx.beginPath();
      ctx.arc(flashX, flashY, 30, 0, Math.PI * 2);
      ctx.fill();

      // Red-orange outer glow
      const outerGrad = ctx.createRadialGradient(flashX, flashY, 20, flashX, flashY, 45);
      outerGrad.addColorStop(0, 'rgba(255, 100, 30, 0.25)');
      outerGrad.addColorStop(1, 'rgba(255, 50, 0, 0)');
      ctx.fillStyle = outerGrad;
      ctx.beginPath();
      ctx.arc(flashX, flashY, 45, 0, Math.PI * 2);
      ctx.fill();

      // Random spokes/rays for variety (2-3 rays)
      ctx.strokeStyle = 'rgba(255, 230, 120, 0.6)';
      ctx.lineWidth = 2;
      const spokeCount = 2 + Math.floor(Math.random() * 2);
      for (let si = 0; si < spokeCount; si++) {
        const sAngle = Math.random() * Math.PI * 2;
        const sLen = 15 + Math.random() * 25;
        ctx.beginPath();
        ctx.moveTo(flashX + Math.cos(sAngle) * 5, flashY + Math.sin(sAngle) * 5);
        ctx.lineTo(flashX + Math.cos(sAngle) * sLen, flashY + Math.sin(sAngle) * sLen);
        ctx.stroke();
      }
    }
  }, []);

  // -----------------------------------------------------------------------
  // Draw HUD
  // -----------------------------------------------------------------------

  const drawHUD = useCallback((ctx: CanvasRenderingContext2D, gs: FPSGameState) => {
    // Bottom bar
    ctx.save();
    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
    ctx.fillRect(0, SCREEN_H - 60, SCREEN_W, 60);

    ctx.font = 'bold 14px monospace';
    ctx.textBaseline = 'middle';

    // Health (left)
    const healthColor =
      gs.playerHealth > 50 ? '#22cc22' : gs.playerHealth > 25 ? '#cccc22' : '#cc2222';
    ctx.fillStyle = '#cc2222';
    ctx.font = 'bold 20px monospace';
    ctx.textAlign = 'left';
    ctx.fillText('+', 20, SCREEN_H - 38);
    ctx.fillStyle = healthColor;
    ctx.font = 'bold 28px monospace';
    ctx.fillText(`${gs.playerHealth}`, 40, SCREEN_H - 35);

    // Armor (next to health)
    if (gs.playerArmor > 0) {
      ctx.fillStyle = '#4488ff';
      ctx.font = 'bold 16px monospace';
      ctx.fillText(`[${gs.playerArmor}]`, 110, SCREEN_H - 35);
    }

    // Weapon and ammo (center)
    const weapon = gs.weapons[gs.currentWeapon];
    ctx.textAlign = 'center';
    ctx.fillStyle = '#ddd';
    ctx.font = 'bold 16px monospace';
    ctx.fillText(weapon.name, SCREEN_W / 2, SCREEN_H - 42);

    if (weapon.ammoType !== null) {
      const ammoColor = weapon.ammo > 10 ? '#ddd' : weapon.ammo > 0 ? '#cccc22' : '#cc2222';
      ctx.fillStyle = ammoColor;
      ctx.font = 'bold 22px monospace';
      ctx.fillText(`${weapon.ammo}`, SCREEN_W / 2, SCREEN_H - 20);
    } else {
      ctx.fillStyle = '#888';
      ctx.font = '14px monospace';
      ctx.fillText('INF', SCREEN_W / 2, SCREEN_H - 20);
    }

    // Score and kills (top left) | In multiplayer, show "Deathmatch" label
    ctx.textAlign = 'left';
    ctx.fillStyle = '#aaa';
    ctx.font = '14px monospace';
    if (gs.multiplayerMode) {
      ctx.fillStyle = '#ff6644';
      ctx.fillText('DEATHMATCH', 10, 20);
      ctx.fillStyle = '#aaa';
      ctx.fillText(`Kills to win: ${gs.killsToWin}`, 10, 38);
    } else {
      ctx.fillText(`Score: ${gs.score}`, 10, 20);
      ctx.fillText(`Kills: ${gs.kills}`, 10, 38);
    }

    // Level name (top right)
    ctx.textAlign = 'right';
    ctx.fillStyle = '#aaa';
    ctx.font = '14px monospace';
    if (!gs.multiplayerMode) {
      const levelDef = LEVELS[gs.level];
      ctx.fillText(levelDef ? levelDef.name : '', SCREEN_W - 130, 20);
    }

    // --- Minimap (top right corner) ---
    const mmSize = 120;
    const mmX = SCREEN_W - mmSize - 10;
    const mmY = 30;

    ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
    ctx.fillRect(mmX, mmY, mmSize, mmSize);

    const cellW = mmSize / gs.mapWidth;
    const cellH = mmSize / gs.mapHeight;

    for (let my = 0; my < gs.mapHeight; my++) {
      for (let mx = 0; mx < gs.mapWidth; mx++) {
        if (gs.map[my][mx] > 0) {
          ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
          ctx.fillRect(mmX + mx * cellW, mmY + my * cellH, cellW, cellH);
        }
      }
    }

    // Player on minimap
    const pmx = mmX + (gs.playerX / gs.mapWidth) * mmSize;
    const pmy = mmY + (gs.playerY / gs.mapHeight) * mmSize;
    ctx.fillStyle = '#22cc22';
    ctx.beginPath();
    ctx.arc(pmx, pmy, 2.5, 0, Math.PI * 2);
    ctx.fill();

    // Direction line
    ctx.strokeStyle = '#22cc22';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(pmx, pmy);
    ctx.lineTo(pmx + Math.cos(gs.playerAngle) * 6, pmy + Math.sin(gs.playerAngle) * 6);
    ctx.stroke();

    // Enemies on minimap
    for (const enemy of gs.enemies) {
      if (!enemy.alive) continue;
      const emx = mmX + (enemy.x / gs.mapWidth) * mmSize;
      const emy = mmY + (enemy.y / gs.mapHeight) * mmSize;
      ctx.fillStyle = '#cc2222';
      ctx.beginPath();
      ctx.arc(emx, emy, 1.5, 0, Math.PI * 2);
      ctx.fill();
    }

    // Remote players on minimap (multiplayer)
    if (gs.multiplayerMode) {
      const playerIds = Array.from(gs.remotePlayers.keys());
      gs.remotePlayers.forEach((remote) => {
        if (!remote.alive) return;
        const rmx = mmX + (remote.x / gs.mapWidth) * mmSize;
        const rmy = mmY + (remote.y / gs.mapHeight) * mmSize;
        const colorIdx = playerIds.indexOf(remote.id) % MP_PLAYER_COLORS.length;
        ctx.fillStyle = MP_PLAYER_COLORS[colorIdx];
        ctx.beginPath();
        ctx.arc(rmx, rmy, 2, 0, Math.PI * 2);
        ctx.fill();
      });
    }

    // Exit on minimap (single-player only)
    if (!gs.multiplayerMode) {
      const exMx = mmX + (gs.exitX / gs.mapWidth) * mmSize;
      const exMy = mmY + (gs.exitY / gs.mapHeight) * mmSize;
      ctx.fillStyle = '#FFD700';
      ctx.beginPath();
      ctx.arc(exMx, exMy, 2, 0, Math.PI * 2);
      ctx.fill();
    }

    // Weapon slots (bottom right) with lock icons for unowned
    ctx.textAlign = 'right';
    ctx.font = '12px monospace';
    const slotY = SCREEN_H - 50;
    for (let i = 0; i < gs.weapons.length; i++) {
      const w = gs.weapons[i];
      const isActive = i === gs.currentWeapon;
      if (w.owned) {
        ctx.fillStyle = isActive ? '#FFD700' : '#666';
        ctx.fillText(`${i + 1}:${w.name.substring(0, 4)}`, SCREEN_W - 20, slotY + i * 14);
      } else {
        // Show grayed out with lock icon
        ctx.fillStyle = '#333';
        ctx.fillText(`${i + 1}:${w.name.substring(0, 4)} [X]`, SCREEN_W - 20, slotY + i * 14);
      }
    }

    // Multiplayer scoreboard (compact, top center)
    if (gs.multiplayerMode && gs.matchStatus === 'playing') {
      drawMultiplayerScoreboard(ctx, gs);
    }

    ctx.restore();
  }, []);

  // -----------------------------------------------------------------------
  // Multiplayer scoreboard
  // -----------------------------------------------------------------------

  function drawMultiplayerScoreboard(ctx: CanvasRenderingContext2D, gs: FPSGameState): void {
    const entries = Object.entries(gs.matchScores).sort((a, b) => b[1].kills - a[1].kills);
    if (entries.length === 0) return;

    const sbX = SCREEN_W / 2;
    const sbY = 8;
    const lineH = 14;
    const sbWidth = 200;
    const sbHeight = entries.length * lineH + 8;

    ctx.save();
    ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
    ctx.fillRect(sbX - sbWidth / 2, sbY, sbWidth, sbHeight);

    ctx.font = '11px monospace';
    ctx.textBaseline = 'top';

    for (let i = 0; i < entries.length; i++) {
      const [id, score] = entries[i];
      const isLocal = id === gs.localPlayerId;
      ctx.textAlign = 'left';
      ctx.fillStyle = isLocal ? '#22cc22' : '#bbbbbb';
      ctx.fillText(score.name, sbX - sbWidth / 2 + 6, sbY + 4 + i * lineH);
      ctx.textAlign = 'right';
      ctx.fillText(
        `K:${score.kills} D:${score.deaths}`,
        sbX + sbWidth / 2 - 6,
        sbY + 4 + i * lineH,
      );
    }

    ctx.restore();
  }

  // -----------------------------------------------------------------------
  // Multiplayer overlay (waiting, countdown, death, match end)
  // -----------------------------------------------------------------------

  function drawMultiplayerOverlay(ctx: CanvasRenderingContext2D, gs: FPSGameState): void {
    ctx.save();
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';

    if (gs.matchStatus === 'connecting') {
      ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
      ctx.fillRect(0, 0, SCREEN_W, SCREEN_H);
      ctx.fillStyle = '#FFD700';
      ctx.font = 'bold 28px monospace';
      ctx.fillText('CONNECTING...', SCREEN_W / 2, SCREEN_H / 2);
    }

    if (gs.matchStatus === 'waiting') {
      ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
      ctx.fillRect(0, 0, SCREEN_W, SCREEN_H);
      ctx.fillStyle = '#FFD700';
      ctx.font = 'bold 28px monospace';
      ctx.fillText(
        `WAITING FOR PLAYERS... ${gs.mpWaitingPlayers}/${gs.mpMaxPlayers}`,
        SCREEN_W / 2,
        SCREEN_H / 2 - 30,
      );

      if (!gs.mpReady) {
        ctx.fillStyle = '#4488ff';
        ctx.font = 'bold 20px monospace';
        ctx.fillText('Press R when ready', SCREEN_W / 2, SCREEN_H / 2 + 20);
      } else {
        ctx.fillStyle = '#22cc22';
        ctx.font = 'bold 20px monospace';
        ctx.fillText('READY!', SCREEN_W / 2, SCREEN_H / 2 + 20);
      }
    }

    if (gs.matchStatus === 'countdown') {
      ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
      ctx.fillRect(0, 0, SCREEN_W, SCREEN_H);

      const countText = gs.countdownSeconds > 0 ? `${gs.countdownSeconds}` : 'FIGHT!';
      const fontSize = gs.countdownSeconds > 0 ? 96 : 72;
      ctx.fillStyle = gs.countdownSeconds > 0 ? '#FFD700' : '#FF4444';
      ctx.font = `bold ${fontSize}px monospace`;
      ctx.fillText(countText, SCREEN_W / 2, SCREEN_H / 2);
    }

    // Death screen
    if (gs.matchStatus === 'playing' && gs.playerHealth <= 0 && gs.mpKilledBy) {
      ctx.fillStyle = 'rgba(100, 0, 0, 0.5)';
      ctx.fillRect(0, 0, SCREEN_W, SCREEN_H);
      ctx.fillStyle = '#FF4444';
      ctx.font = 'bold 32px monospace';
      ctx.fillText(`Killed by ${gs.mpKilledBy}`, SCREEN_W / 2, SCREEN_H / 2 - 20);
      ctx.fillStyle = '#ddd';
      ctx.font = '20px monospace';
      const respawnSec = Math.ceil(Math.max(0, gs.mpRespawnTimer) / 1000);
      ctx.fillText(`Respawning in ${respawnSec}...`, SCREEN_W / 2, SCREEN_H / 2 + 20);
    }

    // Match end screen
    if (gs.matchStatus === 'ended') {
      ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
      ctx.fillRect(0, 0, SCREEN_W, SCREEN_H);

      const isWinner = gs.mpWinnerId === gs.localPlayerId;
      ctx.fillStyle = isWinner ? '#22CC22' : '#FF4444';
      ctx.font = 'bold 56px monospace';
      ctx.fillText(isWinner ? 'VICTORY!' : 'DEFEAT', SCREEN_W / 2, SCREEN_H / 2 - 80);

      // Final scoreboard
      const entries = Object.entries(gs.matchScores).sort((a, b) => b[1].kills - a[1].kills);
      ctx.font = '18px monospace';
      for (let i = 0; i < entries.length; i++) {
        const [id, score] = entries[i];
        const isLocal = id === gs.localPlayerId;
        ctx.fillStyle = isLocal ? '#22cc22' : '#bbbbbb';
        ctx.fillText(
          `${score.name}: ${score.kills} kills / ${score.deaths} deaths`,
          SCREEN_W / 2,
          SCREEN_H / 2 - 20 + i * 28,
        );
      }

      ctx.fillStyle = '#aaa';
      ctx.font = '16px monospace';
      ctx.fillText('Click to exit', SCREEN_W / 2, SCREEN_H / 2 + 100);
    }

    ctx.restore();
  }

  // -----------------------------------------------------------------------
  // Game over screen
  // -----------------------------------------------------------------------

  const drawGameOverScreen = useCallback((ctx: CanvasRenderingContext2D, gs: FPSGameState) => {
    ctx.save();
    ctx.fillStyle = 'rgba(100, 0, 0, 0.6)';
    ctx.fillRect(0, 0, SCREEN_W, SCREEN_H);

    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';

    ctx.fillStyle = '#FF0000';
    ctx.font = 'bold 64px monospace';
    ctx.fillText('YOU DIED', SCREEN_W / 2, SCREEN_H / 2 - 60);

    ctx.fillStyle = '#ddd';
    ctx.font = '20px monospace';
    ctx.fillText(`Score: ${gs.score}`, SCREEN_W / 2, SCREEN_H / 2);
    ctx.fillText(`Kills: ${gs.kills}`, SCREEN_W / 2, SCREEN_H / 2 + 30);
    ctx.fillText(`Level: ${gs.level + 1}`, SCREEN_W / 2, SCREEN_H / 2 + 60);

    ctx.fillStyle = '#aaa';
    ctx.font = '16px monospace';
    ctx.fillText('Click to restart', SCREEN_W / 2, SCREEN_H / 2 + 110);

    ctx.restore();
  }, []);

  // -----------------------------------------------------------------------
  // Victory screen
  // -----------------------------------------------------------------------

  const drawVictoryScreen = useCallback((ctx: CanvasRenderingContext2D, gs: FPSGameState) => {
    ctx.save();
    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
    ctx.fillRect(0, 0, SCREEN_W, SCREEN_H);

    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';

    ctx.fillStyle = '#22CC22';
    ctx.font = 'bold 64px monospace';
    ctx.fillText('VICTORY', SCREEN_W / 2, SCREEN_H / 2 - 80);

    ctx.fillStyle = '#ddd';
    ctx.font = '20px monospace';
    ctx.fillText(`Total Score: ${gs.score}`, SCREEN_W / 2, SCREEN_H / 2 - 20);
    ctx.fillText(`Total Kills: ${gs.kills}`, SCREEN_W / 2, SCREEN_H / 2 + 10);
    ctx.fillText(
      `Secrets Found: ${gs.secretsFound} / ${gs.totalSecrets}`,
      SCREEN_W / 2,
      SCREEN_H / 2 + 40,
    );
    ctx.fillText(
      `Time: ${Math.floor(gs.gameTime / 60)}m ${Math.floor(gs.gameTime % 60)}s`,
      SCREEN_W / 2,
      SCREEN_H / 2 + 70,
    );

    // Show vault unlock hint if applicable
    if (!gs.secretLevelUnlocked && gs.level >= 2) {
      ctx.fillStyle = '#FFD700';
      ctx.font = '14px monospace';
      ctx.fillText(
        'Purchase The Vault Access Key to unlock Level 4!',
        SCREEN_W / 2,
        SCREEN_H / 2 + 100,
      );
    }

    ctx.fillStyle = '#aaa';
    ctx.font = '16px monospace';
    ctx.fillText('Click to play again', SCREEN_W / 2, SCREEN_H / 2 + 130);

    ctx.restore();
  }, []);

  // -----------------------------------------------------------------------
  // Input event handlers
  // -----------------------------------------------------------------------

  useEffect(() => {
    if (!started) return;

    const keys = keysRef.current;

    const onKeyDown = (e: KeyboardEvent) => {
      const k = e.key.toLowerCase();
      if (
        [
          'w',
          'a',
          's',
          'd',
          ' ',
          'q',
          'r',
          'arrowup',
          'arrowdown',
          'arrowleft',
          'arrowright',
          'shift',
          'e',
          '1',
          '2',
          '3',
          '4',
          '5',
          '6',
        ].includes(k)
      ) {
        e.preventDefault();
        keys.add(k);
      }

      // Multiplayer: R for ready
      if (
        k === 'r' &&
        stateRef.current?.multiplayerMode &&
        stateRef.current?.matchStatus === 'waiting'
      ) {
        stateRef.current.mpReady = true;
        stateRef.current.wsRef?.send(JSON.stringify({ type: 'fps_ready' }));
      }
    };

    const onKeyUp = (e: KeyboardEvent) => {
      const k = e.key.toLowerCase();
      keys.delete(k);
    };

    const onMouseMove = (e: MouseEvent) => {
      if (!pointerLockedRef.current) return;
      const gs = stateRef.current;
      if (!gs) return;
      gs.playerAngle += e.movementX * MOUSE_SENSITIVITY;
    };

    const onMouseDown = (e: MouseEvent) => {
      if (e.button === 0) {
        const gs = stateRef.current;
        if (!gs) return;

        // Handle restart on game over / victory
        if (gs.gameOver || gs.victory) {
          initGame(0);
          return;
        }

        keys.add('shooting');
      }
    };

    const onMouseUp = (e: MouseEvent) => {
      if (e.button === 0) {
        keys.delete('shooting');
      }
    };

    const onPointerLockChange = () => {
      pointerLockedRef.current = document.pointerLockElement === canvasRef.current;
    };

    window.addEventListener('keydown', onKeyDown);
    window.addEventListener('keyup', onKeyUp);
    window.addEventListener('mousemove', onMouseMove);
    window.addEventListener('mousedown', onMouseDown);
    window.addEventListener('mouseup', onMouseUp);
    document.addEventListener('pointerlockchange', onPointerLockChange);

    return () => {
      window.removeEventListener('keydown', onKeyDown);
      window.removeEventListener('keyup', onKeyUp);
      window.removeEventListener('mousemove', onMouseMove);
      window.removeEventListener('mousedown', onMouseDown);
      window.removeEventListener('mouseup', onMouseUp);
      document.removeEventListener('pointerlockchange', onPointerLockChange);
    };
  }, [started, initGame]);

  // -----------------------------------------------------------------------
  // Start animation loop
  // -----------------------------------------------------------------------

  useEffect(() => {
    if (!started) return;
    initGame(0);
    rafRef.current = requestAnimationFrame(gameLoop);

    // Setup multiplayer if needed
    const gs = stateRef.current;
    if (gs && gs.multiplayerMode) {
      setupMultiplayer(gs);
    }

    return () => {
      cancelAnimationFrame(rafRef.current);
      // Clean up WebSocket
      if (wsRef.current) {
        wsRef.current.close();
        wsRef.current = null;
      }
    };
  }, [started, gameLoop, initGame, setupMultiplayer]);

  // -----------------------------------------------------------------------
  // Canvas click handler (pointer lock + start)
  // -----------------------------------------------------------------------

  const handleCanvasClick = useCallback(() => {
    if (!started) {
      setStarted(true);
      setShowControls(false);
    }
    const canvas = canvasRef.current;
    if (canvas && !pointerLockedRef.current) {
      canvas.requestPointerLock();
    }
  }, [started]);

  // -----------------------------------------------------------------------
  // JSX
  // -----------------------------------------------------------------------

  const isMultiplayer = (config?.multiplayer as boolean) || false;

  return (
    <div className="flex flex-col items-center gap-4">
      <div style={{ width: '100%', maxWidth: SCREEN_W, margin: '0 auto', position: 'relative' }}>
        <canvas
          ref={canvasRef}
          width={SCREEN_W}
          height={SCREEN_H}
          onClick={handleCanvasClick}
          className="rounded-lg border border-white/10 bg-black cursor-crosshair"
          style={{ width: '100%', height: 'auto', imageRendering: 'pixelated' }}
          tabIndex={0}
        />

        {/* Click to Start overlay */}
        {!started && (
          <div
            style={{
              position: 'absolute',
              top: 0,
              left: 0,
              width: '100%',
              height: '100%',
              display: 'flex',
              flexDirection: 'column',
              alignItems: 'center',
              justifyContent: 'center',
              background: 'rgba(0, 0, 0, 0.85)',
              borderRadius: '0.5rem',
              cursor: 'pointer',
            }}
            onClick={handleCanvasClick}
          >
            <div
              style={{
                color: '#FF4444',
                fontSize: '48px',
                fontWeight: 'bold',
                fontFamily: 'monospace',
                marginBottom: '16px',
              }}
            >
              MOLTBLOX FPS
            </div>
            <div
              style={{
                color: '#FFD700',
                fontSize: '20px',
                fontFamily: 'monospace',
                marginBottom: '8px',
              }}
            >
              {isMultiplayer ? 'DEATHMATCH MODE' : 'Click to Start'}
            </div>
            {isMultiplayer && (
              <div
                style={{
                  color: '#ff8844',
                  fontSize: '14px',
                  fontFamily: 'monospace',
                  marginBottom: '24px',
                }}
              >
                Match ID: {(config?.matchId as string) || 'pending'}
              </div>
            )}
            {showControls && (
              <div
                style={{
                  color: '#aaa',
                  fontSize: '14px',
                  fontFamily: 'monospace',
                  textAlign: 'center',
                  lineHeight: '1.8',
                }}
              >
                <div>WASD: Move | Mouse: Look | Click: Shoot</div>
                <div>1-6: Switch Weapon | Shift: Run | Space: Shoot</div>
                <div>E: Open Door | Q: Use Consumable | Arrow Keys: Turn</div>
                {isMultiplayer && <div>R: Ready Up</div>}
              </div>
            )}

            {/* Secret level lock indicator */}
            {!isMultiplayer && config?.secretLevelUnlocked === false && (
              <div
                style={{
                  color: '#666',
                  fontSize: '12px',
                  fontFamily: 'monospace',
                  marginTop: '16px',
                }}
              >
                Level 4 (The Vault) requires The Vault Access Key
              </div>
            )}
          </div>
        )}
      </div>

      {started && (
        <div className="flex gap-6 text-xs text-white/50">
          <span>
            <kbd className="px-1.5 py-0.5 bg-white/10 rounded text-white/70 font-mono text-[10px]">
              WASD
            </kbd>{' '}
            Move
          </span>
          <span>
            <kbd className="px-1.5 py-0.5 bg-white/10 rounded text-white/70 font-mono text-[10px]">
              Mouse
            </kbd>{' '}
            Look
          </span>
          <span>
            <kbd className="px-1.5 py-0.5 bg-white/10 rounded text-white/70 font-mono text-[10px]">
              Click
            </kbd>{' '}
            Shoot
          </span>
          <span>
            <kbd className="px-1.5 py-0.5 bg-white/10 rounded text-white/70 font-mono text-[10px]">
              1-6
            </kbd>{' '}
            Weapons
          </span>
          <span>
            <kbd className="px-1.5 py-0.5 bg-white/10 rounded text-white/70 font-mono text-[10px]">
              Shift
            </kbd>{' '}
            Run
          </span>
          <span>
            <kbd className="px-1.5 py-0.5 bg-white/10 rounded text-white/70 font-mono text-[10px]">
              E
            </kbd>{' '}
            Door
          </span>
          <span>
            <kbd className="px-1.5 py-0.5 bg-white/10 rounded text-white/70 font-mono text-[10px]">
              Q
            </kbd>{' '}
            Item
          </span>
        </div>
      )}
    </div>
  );
}
